<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Axmol Engine: Sprite Class Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript">
    window.__relpath = "../../";
</script>
<script src="../../hacks.js" type="text/javascript"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
//<![CDATA[
MathJax.Hub.Config(
{
  TeX: {
      Macros: {
          qprel: [ "{\\gtreqless}", 0],
          qpx: [ "{\\mathbf{x}}", 0],
          qpl: [ "{\\mathbf{l}}", 0],
          qpu: [ "{\\mathbf{u}}", 0],
          qpc: [ "{\\mathbf{c}}", 0],
          qpb: [ "{\\mathbf{b}}", 0],
          qpy: [ "{\\mathbf{y}}", 0],
          qpw: [ "{\\mathbf{w}}", 0],
          qplambda: [ "{\\mathbf{\\lambda}}", 0],
          ssWpoint: [ "{\\bf #1}", 1],
          ssWeight: [ "{w_{#1}}", 1],
          dabs: [ "{\\parallel\\! #1 \\!\\parallel}", 1],
          E: [ "{\\mathrm{E}}", 0],
          A: [ "{\\mathrm{A}}", 0],
          R: [ "{\\mathrm{R}}", 0],
          N: [ "{\\mathrm{N}}", 0],
          Q: [ "{\\mathrm{Q}}", 0],
          Z: [ "{\\mathrm{Z}}", 0],
          ccSum: [ "{\\sum_{#1}^{#2}{#3}}", 3],
          ccProd: [ "{\\prod_{#1}^{#2}{#3}}", 3],
          pyr: [ "{\\operatorname{Pyr}}", 0],
          aff: [ "{\\operatorname{aff}}", 0],
          Ac: [ "{\\cal A}", 0],
          Sc: [ "{\\cal S}", 0],
      },
      equationNumbers: { autoNumber: "AMS" }
  }
}
);
//]]>
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<!-- This should probably be an extrastylesheet instead of hardcoded. -->
<link href="../../stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="back-nav">
  <ul>
    <li><a href="https://github.com/axmolengine/axmol">GitHub</a></li>
    <li><a href="../../index.html">Top</a></li>
  </ul>
          <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</div>
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Axmol Engine<span id="projectnumber">&#160;v2.1.5</span>
   </div>
  </td>
    <!--<td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part --><!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('da/d34/classax_1_1_sprite.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="../../d6/d67/classax_1_1_sprite-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Sprite Class Reference<div class="ingroups"><a class="el" href="../../d0/dc7/group____2d.html">2D Nodes</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a> is a 2d image ( <a href="http://en.wikipedia.org/wiki/Sprite_(computer_graphics)">http://en.wikipedia.org/wiki/Sprite_(computer_graphics)</a> ).  
 <a href="../../da/d34/classax_1_1_sprite.html#details">More...</a></p>

<p><code>#include &lt;Sprite.h&gt;</code></p>

<p>Inherits <a class="el" href="../../df/da2/classax_1_1_node.html">Node</a>, and TextureProtocol.</p>

<p>Inherited by <a class="el" href="../../d3/db5/classax_1_1_anchored_sprite.html">AnchoredSprite</a>, <a class="el" href="../../dd/d37/classax_1_1_bill_board.html">BillBoard</a>, <a class="el" href="../../dd/d52/classax_1_1_layer_color.html">LayerColor</a>, and <a class="el" href="../../db/ddc/classax_1_1ui_1_1_scale9_sprite.html">Scale9Sprite</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1bb0bf2cd1ad1bb23ab0a0525899ef62"><td class="memItemLeft" align="right" valign="top"><a id="a1bb0bf2cd1ad1bb23ab0a0525899ef62" name="a1bb0bf2cd1ad1bb23ab0a0525899ef62"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>isFrameDisplayed</b> (<a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html">SpriteFrame</a> *frame) const</td></tr>
<tr class="memdesc:a1bb0bf2cd1ad1bb23ab0a0525899ef62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not a <a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html" title="A SpriteFrame has:">SpriteFrame</a> is being displayed. <br /></td></tr>
<tr class="separator:a1bb0bf2cd1ad1bb23ab0a0525899ef62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73ae0162e025b45ace7fdaff309cc78"><td class="memItemLeft" align="right" valign="top"><a id="ac73ae0162e025b45ace7fdaff309cc78" name="ac73ae0162e025b45ace7fdaff309cc78"></a>
virtual <a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html">SpriteFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getSpriteFrame</b> () const</td></tr>
<tr class="memdesc:ac73ae0162e025b45ace7fdaff309cc78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current displayed frame. <br /></td></tr>
<tr class="separator:ac73ae0162e025b45ace7fdaff309cc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c512ddf90467ffe2f39a036f8425705"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d8/dcb/structax_1_1_v3_f___c4_b___t2_f___quad.html">V3F_C4B_T2F_Quad</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a8c512ddf90467ffe2f39a036f8425705">getQuad</a> () const</td></tr>
<tr class="memdesc:a8c512ddf90467ffe2f39a036f8425705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the quad (tex coords, vertex coords and color) information.  <br /></td></tr>
<tr class="separator:a8c512ddf90467ffe2f39a036f8425705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5727bb591d6dbef5598066112b73a2"><td class="memItemLeft" align="right" valign="top"><a id="acc5727bb591d6dbef5598066112b73a2" name="acc5727bb591d6dbef5598066112b73a2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isTextureRectRotated</b> () const</td></tr>
<tr class="memdesc:acc5727bb591d6dbef5598066112b73a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the texture rectangle is rotated. <br /></td></tr>
<tr class="separator:acc5727bb591d6dbef5598066112b73a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd27c156d299e12bff2d99a76fdc048"><td class="memItemLeft" align="right" valign="top"><a id="a1bd27c156d299e12bff2d99a76fdc048" name="a1bd27c156d299e12bff2d99a76fdc048"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>getAtlasIndex</b> () const</td></tr>
<tr class="memdesc:a1bd27c156d299e12bff2d99a76fdc048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index used on the <a class="el" href="../../de/dd0/classax_1_1_texture_atlas.html" title="A class that implements a Texture Atlas.">TextureAtlas</a>. <br /></td></tr>
<tr class="separator:a1bd27c156d299e12bff2d99a76fdc048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ba1bde12abab899dd477694b2d0440"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a71ba1bde12abab899dd477694b2d0440">setAtlasIndex</a> (unsigned int atlasIndex)</td></tr>
<tr class="memdesc:a71ba1bde12abab899dd477694b2d0440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the index used on the <a class="el" href="../../de/dd0/classax_1_1_texture_atlas.html" title="A class that implements a Texture Atlas.">TextureAtlas</a>.  <br /></td></tr>
<tr class="separator:a71ba1bde12abab899dd477694b2d0440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc20c0bb3373417039b1f6ccd7a1d4f2"><td class="memItemLeft" align="right" valign="top"><a id="acc20c0bb3373417039b1f6ccd7a1d4f2" name="acc20c0bb3373417039b1f6ccd7a1d4f2"></a>
const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getTextureRect</b> () const</td></tr>
<tr class="memdesc:acc20c0bb3373417039b1f6ccd7a1d4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rect of the <a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a> in points. <br /></td></tr>
<tr class="separator:acc20c0bb3373417039b1f6ccd7a1d4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75e98c075d014c17d3f2a909116fa75"><td class="memItemLeft" align="right" valign="top"><a id="aa75e98c075d014c17d3f2a909116fa75" name="aa75e98c075d014c17d3f2a909116fa75"></a>
<a class="el" href="../../de/dd0/classax_1_1_texture_atlas.html">TextureAtlas</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getTextureAtlas</b> () const</td></tr>
<tr class="memdesc:aa75e98c075d014c17d3f2a909116fa75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the weak reference of the <a class="el" href="../../de/dd0/classax_1_1_texture_atlas.html" title="A class that implements a Texture Atlas.">TextureAtlas</a> when the sprite is rendered using via <a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html" title="SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL c...">SpriteBatchNode</a>. <br /></td></tr>
<tr class="separator:aa75e98c075d014c17d3f2a909116fa75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02f55d4d2442acdc945123a1e6357ca"><td class="memItemLeft" align="right" valign="top"><a id="aa02f55d4d2442acdc945123a1e6357ca" name="aa02f55d4d2442acdc945123a1e6357ca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setProgramState</b> (backend::ProgramState *programState, bool ownPS=false) override</td></tr>
<tr class="memdesc:aa02f55d4d2442acdc945123a1e6357ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or Attach new ProgramState. <br /></td></tr>
<tr class="separator:aa02f55d4d2442acdc945123a1e6357ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a4265dc81411e97d53b27e8f318002"><td class="memItemLeft" align="right" valign="top"><a id="aa8a4265dc81411e97d53b27e8f318002" name="aa8a4265dc81411e97d53b27e8f318002"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setTextureAtlas</b> (<a class="el" href="../../de/dd0/classax_1_1_texture_atlas.html">TextureAtlas</a> *textureAtlas)</td></tr>
<tr class="memdesc:aa8a4265dc81411e97d53b27e8f318002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the weak reference of the <a class="el" href="../../de/dd0/classax_1_1_texture_atlas.html" title="A class that implements a Texture Atlas.">TextureAtlas</a> when the sprite is rendered using via <a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html" title="SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL c...">SpriteBatchNode</a>. <br /></td></tr>
<tr class="separator:aa8a4265dc81411e97d53b27e8f318002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad234d0952086e40d256b33d363554bb3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#ad234d0952086e40d256b33d363554bb3">getOffsetPosition</a> () const</td></tr>
<tr class="memdesc:ad234d0952086e40d256b33d363554bb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the offset position of the sprite.  <br /></td></tr>
<tr class="separator:ad234d0952086e40d256b33d363554bb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baa2b07a6417416039b0de8f845156c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a7baa2b07a6417416039b0de8f845156c">isFlippedX</a> () const</td></tr>
<tr class="memdesc:a7baa2b07a6417416039b0de8f845156c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the flag which indicates whether the sprite is flipped horizontally or not.  <br /></td></tr>
<tr class="separator:a7baa2b07a6417416039b0de8f845156c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c337848ad0070a3bdf3e32393a9214"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#ae5c337848ad0070a3bdf3e32393a9214">setFlippedX</a> (bool flippedX)</td></tr>
<tr class="memdesc:ae5c337848ad0070a3bdf3e32393a9214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the sprite should be flipped horizontally or not.  <br /></td></tr>
<tr class="separator:ae5c337848ad0070a3bdf3e32393a9214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7600f94a70e244d43fcb0d6b70423ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#af7600f94a70e244d43fcb0d6b70423ec">isFlippedY</a> () const</td></tr>
<tr class="memdesc:af7600f94a70e244d43fcb0d6b70423ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the flag which indicates whether the sprite is flipped vertically or not.  <br /></td></tr>
<tr class="separator:af7600f94a70e244d43fcb0d6b70423ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab147ec91d225a67202ac401061134f80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#ab147ec91d225a67202ac401061134f80">setFlippedY</a> (bool flippedY)</td></tr>
<tr class="memdesc:ab147ec91d225a67202ac401061134f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the sprite should be flipped vertically or not.  <br /></td></tr>
<tr class="separator:ab147ec91d225a67202ac401061134f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdaaa9a13f44453effcd71d6708da41c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="../../d6/d78/classax_1_1_polygon_info.html">PolygonInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#afdaaa9a13f44453effcd71d6708da41c">getPolygonInfo</a> () const</td></tr>
<tr class="memdesc:afdaaa9a13f44453effcd71d6708da41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a reference of the polygon information associated with this sprite  <br /></td></tr>
<tr class="separator:afdaaa9a13f44453effcd71d6708da41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6d475f3c58155baeb3749538d12dd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a4e6d475f3c58155baeb3749538d12dd8">setPolygonInfo</a> (const <a class="el" href="../../d6/d78/classax_1_1_polygon_info.html">PolygonInfo</a> &amp;info)</td></tr>
<tr class="memdesc:a4e6d475f3c58155baeb3749538d12dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">set the sprite to use this new <a class="el" href="../../d6/d78/classax_1_1_polygon_info.html" title="PolygonInfo is an object holding the required data to display Sprites.">PolygonInfo</a>  <br /></td></tr>
<tr class="separator:a4e6d475f3c58155baeb3749538d12dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ffff02e75de1ba03c5e9dffa4385d5"><td class="memItemLeft" align="right" valign="top"><a id="a53ffff02e75de1ba03c5e9dffa4385d5" name="a53ffff02e75de1ba03c5e9dffa4385d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setStretchEnabled</b> (bool enabled)</td></tr>
<tr class="memdesc:a53ffff02e75de1ba03c5e9dffa4385d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether or not contentSize stretches the sprite's texture <br /></td></tr>
<tr class="separator:a53ffff02e75de1ba03c5e9dffa4385d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1df8d130ba15f8345109e504e0074f"><td class="memItemLeft" align="right" valign="top"><a id="aab1df8d130ba15f8345109e504e0074f" name="aab1df8d130ba15f8345109e504e0074f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isStretchEnabled</b> () const</td></tr>
<tr class="memdesc:aab1df8d130ba15f8345109e504e0074f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether or not contentSize stretches the sprite's texture <br /></td></tr>
<tr class="separator:aab1df8d130ba15f8345109e504e0074f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637dbaba7024234f1dd304df1706c371"><td class="memItemLeft" align="right" valign="top"><a id="a637dbaba7024234f1dd304df1706c371" name="a637dbaba7024234f1dd304df1706c371"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Sprite</b> ()</td></tr>
<tr class="memdesc:a637dbaba7024234f1dd304df1706c371"><td class="mdescLeft">&#160;</td><td class="mdescRight">@js ctor <br /></td></tr>
<tr class="separator:a637dbaba7024234f1dd304df1706c371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ad1fdbf19a0bf60f21e8e565c37d4d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#ab7ad1fdbf19a0bf60f21e8e565c37d4d">initWithTexture</a> (<a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html">Texture2D</a> *texture)</td></tr>
<tr class="memdesc:ab7ad1fdbf19a0bf60f21e8e565c37d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a sprite with a texture.  <br /></td></tr>
<tr class="separator:ab7ad1fdbf19a0bf60f21e8e565c37d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb52d750835b981593a13f12b99c854"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#adcb52d750835b981593a13f12b99c854">initWithPolygon</a> (const <a class="el" href="../../d6/d78/classax_1_1_polygon_info.html">PolygonInfo</a> &amp;info)</td></tr>
<tr class="memdesc:adcb52d750835b981593a13f12b99c854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a sprite with a <a class="el" href="../../d6/d78/classax_1_1_polygon_info.html" title="PolygonInfo is an object holding the required data to display Sprites.">PolygonInfo</a>.  <br /></td></tr>
<tr class="separator:adcb52d750835b981593a13f12b99c854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d1c74e5a8560fa562cc35bbbb994044"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a7d1c74e5a8560fa562cc35bbbb994044">initWithTexture</a> (<a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html">Texture2D</a> *texture, const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="memdesc:a7d1c74e5a8560fa562cc35bbbb994044"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a sprite with a texture and a rect.  <br /></td></tr>
<tr class="separator:a7d1c74e5a8560fa562cc35bbbb994044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad584036b6c0112e5af1f853ff6d350a7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#ad584036b6c0112e5af1f853ff6d350a7">initWithTexture</a> (<a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html">Texture2D</a> *texture, const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;rect, bool rotated)</td></tr>
<tr class="memdesc:ad584036b6c0112e5af1f853ff6d350a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a sprite with a texture and a rect in points, optionally rotated.  <br /></td></tr>
<tr class="separator:ad584036b6c0112e5af1f853ff6d350a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d49741bdfe37368109c434a0f9e3a0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#aa7d49741bdfe37368109c434a0f9e3a0">initWithSpriteFrame</a> (<a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html">SpriteFrame</a> *spriteFrame)</td></tr>
<tr class="memdesc:aa7d49741bdfe37368109c434a0f9e3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a sprite with an <a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html" title="A SpriteFrame has:">SpriteFrame</a>.  <br /></td></tr>
<tr class="separator:aa7d49741bdfe37368109c434a0f9e3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42535d3cc64775aaa3e596888ff2740d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a42535d3cc64775aaa3e596888ff2740d">initWithSpriteFrameName</a> (std::string_view spriteFrameName)</td></tr>
<tr class="memdesc:a42535d3cc64775aaa3e596888ff2740d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a sprite with an sprite frame name.  <br /></td></tr>
<tr class="separator:a42535d3cc64775aaa3e596888ff2740d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e13e3719edd482bd4beab93110878f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a75e13e3719edd482bd4beab93110878f">initWithFile</a> (std::string_view filename)</td></tr>
<tr class="memdesc:a75e13e3719edd482bd4beab93110878f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a sprite with an image filename.  <br /></td></tr>
<tr class="separator:a75e13e3719edd482bd4beab93110878f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dfc880b51f3b1224e8166bf0fe1bfd3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a3dfc880b51f3b1224e8166bf0fe1bfd3">initWithFile</a> (std::string_view filename, const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="memdesc:a3dfc880b51f3b1224e8166bf0fe1bfd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a sprite with an image filename, and a rect.  <br /></td></tr>
<tr class="separator:a3dfc880b51f3b1224e8166bf0fe1bfd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f26a305c777e8053202c00abdda28e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#ab9f26a305c777e8053202c00abdda28e">initWithImageData</a> (const ax::Data &amp;imageData, std::string_view key)</td></tr>
<tr class="memdesc:ab9f26a305c777e8053202c00abdda28e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a sprite with an image data, and a key for the cache.  <br /></td></tr>
<tr class="separator:ab9f26a305c777e8053202c00abdda28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaacdcdb32cf2de74fbedaaad63f8e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a3eaacdcdb32cf2de74fbedaaad63f8e0">setAutoSize</a> (bool enabled)</td></tr>
<tr class="memdesc:a3eaacdcdb32cf2de74fbedaaad63f8e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicate if the sprite content size can change if new textures are applied to the sprite.  <br /></td></tr>
<tr class="separator:a3eaacdcdb32cf2de74fbedaaad63f8e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">BatchNode methods</div></td></tr>
<tr class="memitem:adf19ef4a7d7eb6a3f7d42741c11a9726"><td class="memItemLeft" align="right" valign="top"><a id="adf19ef4a7d7eb6a3f7d42741c11a9726" name="adf19ef4a7d7eb6a3f7d42741c11a9726"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>updateTransform</b> () override</td></tr>
<tr class="memdesc:adf19ef4a7d7eb6a3f7d42741c11a9726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the quad according the rotation, position, scale values. <br /></td></tr>
<tr class="separator:adf19ef4a7d7eb6a3f7d42741c11a9726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eeafc1ef5d6974e5250aa433eff7f24"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html">SpriteBatchNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a4eeafc1ef5d6974e5250aa433eff7f24">getBatchNode</a> () const</td></tr>
<tr class="memdesc:a4eeafc1ef5d6974e5250aa433eff7f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the batch node object if this sprite is rendered by <a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html" title="SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL c...">SpriteBatchNode</a>.  <br /></td></tr>
<tr class="separator:a4eeafc1ef5d6974e5250aa433eff7f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091145ef619babb53505061d34393d2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a091145ef619babb53505061d34393d2b">setBatchNode</a> (<a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html">SpriteBatchNode</a> *spriteBatchNode)</td></tr>
<tr class="memdesc:a091145ef619babb53505061d34393d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the batch node to sprite.  <br /></td></tr>
<tr class="separator:a091145ef619babb53505061d34393d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Texture / Frame methods</div></td></tr>
<tr class="memitem:aed377e7e78da4553c84ec3d96793077b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#aed377e7e78da4553c84ec3d96793077b">setTexture</a> (std::string_view filename)</td></tr>
<tr class="memdesc:aed377e7e78da4553c84ec3d96793077b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a new texture (from a filename) to the sprite.  <br /></td></tr>
<tr class="separator:aed377e7e78da4553c84ec3d96793077b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3fe65130fa3d800d4e30753e833975"><td class="memItemLeft" align="right" valign="top"><a id="aba3fe65130fa3d800d4e30753e833975" name="aba3fe65130fa3d800d4e30753e833975"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setTexture</b> (<a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html">Texture2D</a> *texture) override</td></tr>
<tr class="memdesc:aba3fe65130fa3d800d4e30753e833975"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.The Texture's rect is not changed. <br /></td></tr>
<tr class="separator:aba3fe65130fa3d800d4e30753e833975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b2c25c0b446c4c3bad33ae82163767"><td class="memItemLeft" align="right" valign="top"><a id="ac5b2c25c0b446c4c3bad33ae82163767" name="ac5b2c25c0b446c4c3bad33ae82163767"></a>
virtual <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html">Texture2D</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getTexture</b> () const override</td></tr>
<tr class="memdesc:ac5b2c25c0b446c4c3bad33ae82163767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> object used by the sprite. <br /></td></tr>
<tr class="separator:ac5b2c25c0b446c4c3bad33ae82163767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad527178ae1d61e6898dfca6f3eb76dde"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#ad527178ae1d61e6898dfca6f3eb76dde">setTextureRect</a> (const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="memdesc:ad527178ae1d61e6898dfca6f3eb76dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the texture rect of the <a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a> in points.  <br /></td></tr>
<tr class="separator:ad527178ae1d61e6898dfca6f3eb76dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71150a4387c1350adc2de58b42670b27"><td class="memItemLeft" align="right" valign="top"><a id="a71150a4387c1350adc2de58b42670b27" name="a71150a4387c1350adc2de58b42670b27"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setTextureRect</b> (const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;rect, bool rotated, const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;untrimmedSize)</td></tr>
<tr class="memdesc:a71150a4387c1350adc2de58b42670b27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts.It will update the texture coordinates and the vertex rectangle. <br /></td></tr>
<tr class="separator:a71150a4387c1350adc2de58b42670b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b614df84073daab9f8c6bf103e33585"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a4b614df84073daab9f8c6bf103e33585">setVertexRect</a> (const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="memdesc:a4b614df84073daab9f8c6bf103e33585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the vertex rect.  <br /></td></tr>
<tr class="separator:a4b614df84073daab9f8c6bf103e33585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7733443f098f372d222b9414f130e35e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a7733443f098f372d222b9414f130e35e">setCenterRectNormalized</a> (const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="memdesc:a7733443f098f372d222b9414f130e35e"><td class="mdescLeft">&#160;</td><td class="mdescRight">setCenterRectNormalized  <br /></td></tr>
<tr class="separator:a7733443f098f372d222b9414f130e35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8e6939810e53e95bd124dfcf228ef8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a7d8e6939810e53e95bd124dfcf228ef8">getCenterRectNormalized</a> () const</td></tr>
<tr class="memdesc:a7d8e6939810e53e95bd124dfcf228ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">getCenterRectNormalized  <br /></td></tr>
<tr class="separator:a7d8e6939810e53e95bd124dfcf228ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8925da3cd8a509e4e5f83a0fa1358dae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a8925da3cd8a509e4e5f83a0fa1358dae">getCenterRect</a> () const</td></tr>
<tr class="memdesc:a8925da3cd8a509e4e5f83a0fa1358dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Cap Insets rect.  <br /></td></tr>
<tr class="separator:a8925da3cd8a509e4e5f83a0fa1358dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84b905afd2729bf7723055c23cb1405"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#aa84b905afd2729bf7723055c23cb1405">setSpriteFrame</a> (std::string_view spriteFrameName)</td></tr>
<tr class="separator:aa84b905afd2729bf7723055c23cb1405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Animation methods</div></td></tr>
<tr class="memitem:aa5f5665fee653d2ad306257772f78ff2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#aa5f5665fee653d2ad306257772f78ff2">setDisplayFrameWithAnimationName</a> (std::string_view animationName, unsigned int frameIndex)</td></tr>
<tr class="memdesc:aa5f5665fee653d2ad306257772f78ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the display frame with animation name and index.  <br /></td></tr>
<tr class="separator:aa5f5665fee653d2ad306257772f78ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Sprite Properties' setter/getters.</div></td></tr>
<tr class="memitem:af1e28704e545c423a0551118fc31b7d6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#af1e28704e545c423a0551118fc31b7d6">isDirty</a> () const</td></tr>
<tr class="memdesc:af1e28704e545c423a0551118fc31b7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether or not the <a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a> needs to be updated in the Atlas.  <br /></td></tr>
<tr class="separator:af1e28704e545c423a0551118fc31b7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc6a803bf8aab25672ac009aa32f695"><td class="memItemLeft" align="right" valign="top"><a id="a7cc6a803bf8aab25672ac009aa32f695" name="a7cc6a803bf8aab25672ac009aa32f695"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setDirty</b> (bool dirty)</td></tr>
<tr class="memdesc:a7cc6a803bf8aab25672ac009aa32f695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the <a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a> to be updated in the Atlas. <br /></td></tr>
<tr class="separator:a7cc6a803bf8aab25672ac009aa32f695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b7741f1ccd38d665e153882b7dc0dd"><td class="memItemLeft" align="right" valign="top"><a id="a52b7741f1ccd38d665e153882b7dc0dd" name="a52b7741f1ccd38d665e153882b7dc0dd"></a>
virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><b>getDescription</b> () const override</td></tr>
<tr class="memdesc:a52b7741f1ccd38d665e153882b7dc0dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">@js NA <br /></td></tr>
<tr class="separator:a52b7741f1ccd38d665e153882b7dc0dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions inherited from Node.</div></td></tr>
<tr class="memitem:abbf536d9e9fdbdb51ed9337fe9ddccd1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#abbf536d9e9fdbdb51ed9337fe9ddccd1">setScaleX</a> (float scaleX) override</td></tr>
<tr class="memdesc:abbf536d9e9fdbdb51ed9337fe9ddccd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scale (x) of the node.  <br /></td></tr>
<tr class="separator:abbf536d9e9fdbdb51ed9337fe9ddccd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff1c296d7635bcbf74e6afbd75bf2c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a0ff1c296d7635bcbf74e6afbd75bf2c8">setScaleY</a> (float scaleY) override</td></tr>
<tr class="memdesc:a0ff1c296d7635bcbf74e6afbd75bf2c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scale (y) of the node.  <br /></td></tr>
<tr class="separator:a0ff1c296d7635bcbf74e6afbd75bf2c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a101451c2fcd3e847ad10e8c04d757"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a10a101451c2fcd3e847ad10e8c04d757">setScale</a> (float scaleX, float scaleY) override</td></tr>
<tr class="memdesc:a10a101451c2fcd3e847ad10e8c04d757"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scale (x,y) of the node.  <br /></td></tr>
<tr class="separator:a10a101451c2fcd3e847ad10e8c04d757"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1be6ca229d92a1a145fda8a7eece771"><td class="memItemLeft" align="right" valign="top"><a id="ac1be6ca229d92a1a145fda8a7eece771" name="ac1be6ca229d92a1a145fda8a7eece771"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>setPosition</b> (const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;pos) override</td></tr>
<tr class="memdesc:ac1be6ca229d92a1a145fda8a7eece771"><td class="mdescLeft">&#160;</td><td class="mdescRight">@js NA @lua NA <br /></td></tr>
<tr class="separator:ac1be6ca229d92a1a145fda8a7eece771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915b097d1f266fd315ab2151e5af887d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a915b097d1f266fd315ab2151e5af887d">setPosition</a> (float x, float y) override</td></tr>
<tr class="memdesc:a915b097d1f266fd315ab2151e5af887d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position (x,y) of the node in its parent's coordinate system.  <br /></td></tr>
<tr class="separator:a915b097d1f266fd315ab2151e5af887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8fc948a289f8628745bc4c7f382996"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a9d8fc948a289f8628745bc4c7f382996">setRotation</a> (float rotation) override</td></tr>
<tr class="memdesc:a9d8fc948a289f8628745bc4c7f382996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the rotation (angle) of the node in degrees.  <br /></td></tr>
<tr class="separator:a9d8fc948a289f8628745bc4c7f382996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960d510ca897a764062a0bf22fa3dbc3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a960d510ca897a764062a0bf22fa3dbc3">setRotationSkewX</a> (float rotationX) override</td></tr>
<tr class="memdesc:a960d510ca897a764062a0bf22fa3dbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the X rotation (angle) of the node in degrees which performs a horizontal rotational skew.  <br /></td></tr>
<tr class="separator:a960d510ca897a764062a0bf22fa3dbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa805b84f34c11e8b9d4e9c1d6cba1c7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#afa805b84f34c11e8b9d4e9c1d6cba1c7">setRotationSkewY</a> (float rotationY) override</td></tr>
<tr class="memdesc:afa805b84f34c11e8b9d4e9c1d6cba1c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew.  <br /></td></tr>
<tr class="separator:afa805b84f34c11e8b9d4e9c1d6cba1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddb221e19282c51743bf18c5be81b73"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a0ddb221e19282c51743bf18c5be81b73">setSkewX</a> (float sx) override</td></tr>
<tr class="memdesc:a0ddb221e19282c51743bf18c5be81b73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the X skew angle of the node in degrees.  <br /></td></tr>
<tr class="separator:a0ddb221e19282c51743bf18c5be81b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb24aba0a9f48408005c6fa2185ea6a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#acdb24aba0a9f48408005c6fa2185ea6a">setSkewY</a> (float sy) override</td></tr>
<tr class="memdesc:acdb24aba0a9f48408005c6fa2185ea6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the Y skew angle of the node in degrees.  <br /></td></tr>
<tr class="separator:acdb24aba0a9f48408005c6fa2185ea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b91371184c82988923c933c0a52bd98"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a7b91371184c82988923c933c0a52bd98">removeChild</a> (<a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *child, bool <a class="el" href="../../df/da2/classax_1_1_node.html#a09f4fe805fa9a54d4d68c5b29c1502e1">cleanup</a>=true) override</td></tr>
<tr class="memdesc:a7b91371184c82988923c933c0a52bd98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a child from the container.  <br /></td></tr>
<tr class="separator:a7b91371184c82988923c933c0a52bd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadf73dfdd41e1754ef0e2c65dff30755"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#aadf73dfdd41e1754ef0e2c65dff30755">removeAllChildrenWithCleanup</a> (bool <a class="el" href="../../df/da2/classax_1_1_node.html#a09f4fe805fa9a54d4d68c5b29c1502e1">cleanup</a>) override</td></tr>
<tr class="memdesc:aadf73dfdd41e1754ef0e2c65dff30755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all children from the container, and do a cleanup to all running actions depending on the cleanup parameter.  <br /></td></tr>
<tr class="separator:aadf73dfdd41e1754ef0e2c65dff30755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1461c8513c94a6c205448da6d23fef28"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a1461c8513c94a6c205448da6d23fef28">reorderChild</a> (<a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *child, int zOrder) override</td></tr>
<tr class="memdesc:a1461c8513c94a6c205448da6d23fef28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorders a child according to a new z value.  <br /></td></tr>
<tr class="separator:a1461c8513c94a6c205448da6d23fef28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc3fb695690f6b9a722415004eefb24"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a9bc3fb695690f6b9a722415004eefb24">addChild</a> (<a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *child, int zOrder, int tag) override</td></tr>
<tr class="memdesc:a9bc3fb695690f6b9a722415004eefb24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a child to the container with z order and tag.  <br /></td></tr>
<tr class="separator:a9bc3fb695690f6b9a722415004eefb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3fef288b1bdfbc5c81d17189ef5bf1a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#ab3fef288b1bdfbc5c81d17189ef5bf1a">addChild</a> (<a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *child, int zOrder, std::string_view name) override</td></tr>
<tr class="memdesc:ab3fef288b1bdfbc5c81d17189ef5bf1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a child to the container with z order and tag.  <br /></td></tr>
<tr class="separator:ab3fef288b1bdfbc5c81d17189ef5bf1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5dacbfb9541bde2108ad94edbbe6cc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#aff5dacbfb9541bde2108ad94edbbe6cc">sortAllChildren</a> () override</td></tr>
<tr class="memdesc:aff5dacbfb9541bde2108ad94edbbe6cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the children array once before drawing, instead of every time when a child is added or reordered.  <br /></td></tr>
<tr class="separator:aff5dacbfb9541bde2108ad94edbbe6cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8cb6b2364f18f8b8cb2abc9fe6828f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#aba8cb6b2364f18f8b8cb2abc9fe6828f">setScale</a> (float scale) override</td></tr>
<tr class="memdesc:aba8cb6b2364f18f8b8cb2abc9fe6828f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the scale (x,y,z) of the node.  <br /></td></tr>
<tr class="separator:aba8cb6b2364f18f8b8cb2abc9fe6828f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815dbbcdb2a48189e685166f3e71926c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a815dbbcdb2a48189e685166f3e71926c">setPositionZ</a> (float positionZ) override</td></tr>
<tr class="memdesc:a815dbbcdb2a48189e685166f3e71926c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the 'z' coordinate in the position.  <br /></td></tr>
<tr class="separator:a815dbbcdb2a48189e685166f3e71926c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e6d20338e65d260f589c188305df66"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a27e6d20338e65d260f589c188305df66">setAnchorPoint</a> (const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;anchor) override</td></tr>
<tr class="memdesc:a27e6d20338e65d260f589c188305df66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the anchor point in percent.  <br /></td></tr>
<tr class="separator:a27e6d20338e65d260f589c188305df66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a10bd40ac7cd657d96075196cadc681"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a4a10bd40ac7cd657d96075196cadc681">setContentSize</a> (const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;size) override</td></tr>
<tr class="memdesc:a4a10bd40ac7cd657d96075196cadc681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the untransformed size of the node.  <br /></td></tr>
<tr class="separator:a4a10bd40ac7cd657d96075196cadc681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e159ab16183d5412ba16b0c25fbc1b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#aa3e159ab16183d5412ba16b0c25fbc1b">setIgnoreAnchorPointForPosition</a> (bool value) override</td></tr>
<tr class="memdesc:aa3e159ab16183d5412ba16b0c25fbc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the anchor point will be (0,0) when you position this node.  <br /></td></tr>
<tr class="separator:aa3e159ab16183d5412ba16b0c25fbc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df7f98422c04133e00f03324078ac78"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a6df7f98422c04133e00f03324078ac78">setVisible</a> (bool bVisible) override</td></tr>
<tr class="memdesc:a6df7f98422c04133e00f03324078ac78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets whether the node is visible.  <br /></td></tr>
<tr class="separator:a6df7f98422c04133e00f03324078ac78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f59730fa0bd109f318e0a18bb4f8945"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a0f59730fa0bd109f318e0a18bb4f8945">draw</a> (Renderer *renderer, const <a class="el" href="../../d8/d6e/classax_1_1_mat4.html">Mat4</a> &amp;transform, uint32_t flags) override</td></tr>
<tr class="memdesc:a0f59730fa0bd109f318e0a18bb4f8945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method to draw your own node.  <br /></td></tr>
<tr class="separator:a0f59730fa0bd109f318e0a18bb4f8945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8279c03b7acf14855fa31c1ad08abb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a1e8279c03b7acf14855fa31c1ad08abb">setOpacityModifyRGB</a> (bool modify) override</td></tr>
<tr class="memdesc:a1e8279c03b7acf14855fa31c1ad08abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you want the opacity affect the color property, then set to true.  <br /></td></tr>
<tr class="separator:a1e8279c03b7acf14855fa31c1ad08abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a218c437a2b29c7aef17438229c292a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a1a218c437a2b29c7aef17438229c292a">isOpacityModifyRGB</a> () const override</td></tr>
<tr class="memdesc:a1a218c437a2b29c7aef17438229c292a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If node opacity will modify the RGB color value, then you should override this method and return true.  <br /></td></tr>
<tr class="separator:a1a218c437a2b29c7aef17438229c292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1f21f77c26adee1ce1444b31c69178"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#aaa1f21f77c26adee1ce1444b31c69178">addChild</a> (<a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *child)</td></tr>
<tr class="memdesc:aaa1f21f77c26adee1ce1444b31c69178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a child to the container with z-order as 0.  <br /></td></tr>
<tr class="separator:aaa1f21f77c26adee1ce1444b31c69178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3ae9edda24b62e88cc6e76c4201b7a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a8f3ae9edda24b62e88cc6e76c4201b7a">addChild</a> (<a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *child, int localZOrder)</td></tr>
<tr class="memdesc:a8f3ae9edda24b62e88cc6e76c4201b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a child to the container with a local z-order.  <br /></td></tr>
<tr class="separator:a8f3ae9edda24b62e88cc6e76c4201b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81750b6b1e67c0e99c71bae5ce5779bc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a81750b6b1e67c0e99c71bae5ce5779bc">addChild</a> (<a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *child, int localZOrder, int tag)</td></tr>
<tr class="memdesc:a81750b6b1e67c0e99c71bae5ce5779bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a child to the container with z order and tag.  <br /></td></tr>
<tr class="separator:a81750b6b1e67c0e99c71bae5ce5779bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4f157c6f3d4e9f3da98d05b53e061b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#abd4f157c6f3d4e9f3da98d05b53e061b">addChild</a> (<a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *child, int localZOrder, std::string_view name)</td></tr>
<tr class="memdesc:abd4f157c6f3d4e9f3da98d05b53e061b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a child to the container with z order and tag.  <br /></td></tr>
<tr class="separator:abd4f157c6f3d4e9f3da98d05b53e061b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions inherited from TextureProtocol.</div></td></tr>
<tr class="memitem:a8260900844faf4e9e4261f1477b07b1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a8260900844faf4e9e4261f1477b07b1a">setBlendFunc</a> (const <a class="el" href="../../d4/df9/structax_1_1_blend_func.html">BlendFunc</a> &amp;blendFunc) override</td></tr>
<tr class="separator:a8260900844faf4e9e4261f1477b07b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee10309548f7d06437d4dabf2705256c"><td class="memItemLeft" align="right" valign="top"><a id="aee10309548f7d06437d4dabf2705256c" name="aee10309548f7d06437d4dabf2705256c"></a>
const <a class="el" href="../../d4/df9/structax_1_1_blend_func.html">BlendFunc</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getBlendFunc</b> () const override</td></tr>
<tr class="memdesc:aee10309548f7d06437d4dabf2705256c"><td class="mdescLeft">&#160;</td><td class="mdescRight">@js NA @lua NA <br /></td></tr>
<tr class="separator:aee10309548f7d06437d4dabf2705256c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classax_1_1_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classax_1_1_node')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../df/da2/classax_1_1_node.html">Node</a></td></tr>
<tr class="memitem:a05ead6c4ed5f33502d94a26a3fdd8faa inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a05ead6c4ed5f33502d94a26a3fdd8faa">isRunning</a> () const</td></tr>
<tr class="memdesc:a05ead6c4ed5f33502d94a26a3fdd8faa inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the node is "running".  <br /></td></tr>
<tr class="separator:a05ead6c4ed5f33502d94a26a3fdd8faa inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bdb539db127cdcce7a90f3e716b628 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a94bdb539db127cdcce7a90f3e716b628">scheduleUpdateWithPriorityLua</a> (int handler, int priority)</td></tr>
<tr class="memdesc:a94bdb539db127cdcce7a90f3e716b628 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules for lua script.  <br /></td></tr>
<tr class="separator:a94bdb539db127cdcce7a90f3e716b628 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f4fe805fa9a54d4d68c5b29c1502e1 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>cleanup</b> ()</td></tr>
<tr class="memdesc:a09f4fe805fa9a54d4d68c5b29c1502e1 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops all running actions and schedulers. <br /></td></tr>
<tr class="separator:a09f4fe805fa9a54d4d68c5b29c1502e1 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf06584207d830ad5604f077667bbf4 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#afbf06584207d830ad5604f077667bbf4">draw</a> (Renderer *renderer, const <a class="el" href="../../d8/d6e/classax_1_1_mat4.html">Mat4</a> &amp;transform, uint32_t flags)</td></tr>
<tr class="memdesc:afbf06584207d830ad5604f077667bbf4 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override this method to draw your own node.  <br /></td></tr>
<tr class="separator:afbf06584207d830ad5604f077667bbf4 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669cab0ff9c3767eda88537d008f51fb inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a669cab0ff9c3767eda88537d008f51fb">visit</a> (Renderer *renderer, const <a class="el" href="../../d8/d6e/classax_1_1_mat4.html">Mat4</a> &amp;parentTransform, uint32_t parentFlags)</td></tr>
<tr class="memdesc:a669cab0ff9c3767eda88537d008f51fb inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visits this node's children and draw them recursively.  <br /></td></tr>
<tr class="separator:a669cab0ff9c3767eda88537d008f51fb inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35b8528241663d3296bc0f7eb9997c2 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../de/db8/classax_1_1_scene.html">Scene</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ac35b8528241663d3296bc0f7eb9997c2">getScene</a> () const</td></tr>
<tr class="memdesc:ac35b8528241663d3296bc0f7eb9997c2 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="../../de/db8/classax_1_1_scene.html" title="Scene is a subclass of Node that is used only as an abstract concept.">Scene</a> that contains the <a class="el" href="../../df/da2/classax_1_1_node.html" title="Node is the base element of the Scene Graph.">Node</a>.  <br /></td></tr>
<tr class="separator:ac35b8528241663d3296bc0f7eb9997c2 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5487629f67c73c88055b3effc663ad1 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#aa5487629f67c73c88055b3effc663ad1">getBoundingBox</a> () const</td></tr>
<tr class="memdesc:aa5487629f67c73c88055b3effc663ad1 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an <a class="el" href="../../da/d87/classax_1_1_a_a_b_b.html" title="Axis Aligned Bounding Box (AABB), usually calculate some rough but fast collision detection.">AABB</a> (axis-aligned bounding-box) in its parent's coordinate system.  <br /></td></tr>
<tr class="separator:aa5487629f67c73c88055b3effc663ad1 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab575ee12c0e87e97ff131c0be7eee48f inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ab575ee12c0e87e97ff131c0be7eee48f">setEventDispatcher</a> (<a class="el" href="../../de/d23/classax_1_1_event_dispatcher.html">EventDispatcher</a> *dispatcher)</td></tr>
<tr class="memdesc:ab575ee12c0e87e97ff131c0be7eee48f inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set event dispatcher for scene.  <br /></td></tr>
<tr class="separator:ab575ee12c0e87e97ff131c0be7eee48f inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18c471314f5ba4f5bc79ac457c77e5b inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../de/d23/classax_1_1_event_dispatcher.html">EventDispatcher</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ab18c471314f5ba4f5bc79ac457c77e5b">getEventDispatcher</a> () const</td></tr>
<tr class="memdesc:ab18c471314f5ba4f5bc79ac457c77e5b inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the event dispatcher of scene.  <br /></td></tr>
<tr class="separator:ab18c471314f5ba4f5bc79ac457c77e5b inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23673d834c4e353a68c5ee26491b4f1b inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a23673d834c4e353a68c5ee26491b4f1b">getOpacity</a> () const</td></tr>
<tr class="memdesc:a23673d834c4e353a68c5ee26491b4f1b inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node's opacity.  <br /></td></tr>
<tr class="separator:a23673d834c4e353a68c5ee26491b4f1b inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9409c9971582e4899d8a32d11fb18d inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#acd9409c9971582e4899d8a32d11fb18d">getDisplayedOpacity</a> () const</td></tr>
<tr class="memdesc:acd9409c9971582e4899d8a32d11fb18d inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the node's display opacity.  <br /></td></tr>
<tr class="separator:acd9409c9971582e4899d8a32d11fb18d inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0144be094b1369f634a4e576fb8898e0 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a0144be094b1369f634a4e576fb8898e0">setOpacity</a> (uint8_t opacity)</td></tr>
<tr class="memdesc:a0144be094b1369f634a4e576fb8898e0 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change node opacity.  <br /></td></tr>
<tr class="separator:a0144be094b1369f634a4e576fb8898e0 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7a28aaf1c30580446c2f69addb214d inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a9e7a28aaf1c30580446c2f69addb214d">updateDisplayedOpacity</a> (uint8_t parentOpacity)</td></tr>
<tr class="memdesc:a9e7a28aaf1c30580446c2f69addb214d inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the displayed opacity of node with it's parent opacity;.  <br /></td></tr>
<tr class="separator:a9e7a28aaf1c30580446c2f69addb214d inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b6992d288d6ecfec4dc1efd3486565 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a53b6992d288d6ecfec4dc1efd3486565">isCascadeOpacityEnabled</a> () const</td></tr>
<tr class="memdesc:a53b6992d288d6ecfec4dc1efd3486565 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether cascadeOpacity is enabled or not.  <br /></td></tr>
<tr class="separator:a53b6992d288d6ecfec4dc1efd3486565 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040b0cd067148c0c9c4adf9b528ae6f1 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a040b0cd067148c0c9c4adf9b528ae6f1">setCascadeOpacityEnabled</a> (bool cascadeOpacityEnabled)</td></tr>
<tr class="memdesc:a040b0cd067148c0c9c4adf9b528ae6f1 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change node's cascadeOpacity property.  <br /></td></tr>
<tr class="separator:a040b0cd067148c0c9c4adf9b528ae6f1 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd5b8f81f9e95039f6f8d2682548c6e inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d7/d07/structax_1_1_color3_b.html">Color3B</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#afbd5b8f81f9e95039f6f8d2682548c6e">getColor</a> () const</td></tr>
<tr class="memdesc:afbd5b8f81f9e95039f6f8d2682548c6e inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query node's color value.  <br /></td></tr>
<tr class="separator:afbd5b8f81f9e95039f6f8d2682548c6e inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f9c0480b9d2e7c1a33ab4af4056208 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d7/d07/structax_1_1_color3_b.html">Color3B</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a80f9c0480b9d2e7c1a33ab4af4056208">getDisplayedColor</a> () const</td></tr>
<tr class="memdesc:a80f9c0480b9d2e7c1a33ab4af4056208 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query node's displayed color.  <br /></td></tr>
<tr class="separator:a80f9c0480b9d2e7c1a33ab4af4056208 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48b9e1e9d18827fd07163594dc3ed84 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ae48b9e1e9d18827fd07163594dc3ed84">setColor</a> (const <a class="el" href="../../d7/d07/structax_1_1_color3_b.html">Color3B</a> &amp;color)</td></tr>
<tr class="memdesc:ae48b9e1e9d18827fd07163594dc3ed84 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the color of node.  <br /></td></tr>
<tr class="separator:ae48b9e1e9d18827fd07163594dc3ed84 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac516fb10ad56f38c08570434d1e8f9f6 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ac516fb10ad56f38c08570434d1e8f9f6">updateDisplayedColor</a> (const <a class="el" href="../../d7/d07/structax_1_1_color3_b.html">Color3B</a> &amp;parentColor)</td></tr>
<tr class="memdesc:ac516fb10ad56f38c08570434d1e8f9f6 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update node's displayed color with its parent color.  <br /></td></tr>
<tr class="separator:ac516fb10ad56f38c08570434d1e8f9f6 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a5bb1ed7dfb9236ae1030dd2de1d5f inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ae0a5bb1ed7dfb9236ae1030dd2de1d5f">isCascadeColorEnabled</a> () const</td></tr>
<tr class="memdesc:ae0a5bb1ed7dfb9236ae1030dd2de1d5f inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query whether cascadeColor is enabled or not.  <br /></td></tr>
<tr class="separator:ae0a5bb1ed7dfb9236ae1030dd2de1d5f inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f5bdbe8da1c4a48753114c9c6bd9ec inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a05f5bdbe8da1c4a48753114c9c6bd9ec">setCascadeColorEnabled</a> (bool cascadeColorEnabled)</td></tr>
<tr class="memdesc:a05f5bdbe8da1c4a48753114c9c6bd9ec inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you want node's color affect the children node's color, then set it to true.  <br /></td></tr>
<tr class="separator:a05f5bdbe8da1c4a48753114c9c6bd9ec inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6463289cc9eeb21a62835f961be61b12 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a6463289cc9eeb21a62835f961be61b12">setOpacityModifyRGB</a> (bool value)</td></tr>
<tr class="memdesc:a6463289cc9eeb21a62835f961be61b12 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">If you want the opacity affect the color property, then set to true.  <br /></td></tr>
<tr class="separator:a6463289cc9eeb21a62835f961be61b12 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9991c954066be613624f4692d6146988 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a9991c954066be613624f4692d6146988">isOpacityModifyRGB</a> () const</td></tr>
<tr class="memdesc:a9991c954066be613624f4692d6146988 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">If node opacity will modify the RGB color value, then you should override this method and return true.  <br /></td></tr>
<tr class="separator:a9991c954066be613624f4692d6146988 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd291a10cb6ade77eefd96a366ed4d16 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#acd291a10cb6ade77eefd96a366ed4d16">setOnEnterCallback</a> (const std::function&lt; void()&gt; &amp;callback)</td></tr>
<tr class="memdesc:acd291a10cb6ade77eefd96a366ed4d16 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback of event onEnter.  <br /></td></tr>
<tr class="separator:acd291a10cb6ade77eefd96a366ed4d16 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dbc9cbb7c7ff9871d0131554d9f4a8 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a68dbc9cbb7c7ff9871d0131554d9f4a8">getOnEnterCallback</a> () const</td></tr>
<tr class="memdesc:a68dbc9cbb7c7ff9871d0131554d9f4a8 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the callback of event onEnter.  <br /></td></tr>
<tr class="separator:a68dbc9cbb7c7ff9871d0131554d9f4a8 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c2aac96becc8765d136768c99887b2 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a36c2aac96becc8765d136768c99887b2">setOnExitCallback</a> (const std::function&lt; void()&gt; &amp;callback)</td></tr>
<tr class="memdesc:a36c2aac96becc8765d136768c99887b2 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback of event onExit.  <br /></td></tr>
<tr class="separator:a36c2aac96becc8765d136768c99887b2 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88174da63a44caba5d7097b44e13a67b inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a88174da63a44caba5d7097b44e13a67b">getOnExitCallback</a> () const</td></tr>
<tr class="memdesc:a88174da63a44caba5d7097b44e13a67b inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the callback of event onExit.  <br /></td></tr>
<tr class="separator:a88174da63a44caba5d7097b44e13a67b inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3622c5ab30baddf262262950ab04a5 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a3e3622c5ab30baddf262262950ab04a5">setOnEnterTransitionDidFinishCallback</a> (const std::function&lt; void()&gt; &amp;callback)</td></tr>
<tr class="memdesc:a3e3622c5ab30baddf262262950ab04a5 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback of event EnterTransitionDidFinish.  <br /></td></tr>
<tr class="separator:a3e3622c5ab30baddf262262950ab04a5 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac935bd3f3c7ae80e7ffef78ab92a696e inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ac935bd3f3c7ae80e7ffef78ab92a696e">getOnEnterTransitionDidFinishCallback</a> () const</td></tr>
<tr class="memdesc:ac935bd3f3c7ae80e7ffef78ab92a696e inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the callback of event EnterTransitionDidFinish.  <br /></td></tr>
<tr class="separator:ac935bd3f3c7ae80e7ffef78ab92a696e inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493b56ca2e501911ee3f16810c564216 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a493b56ca2e501911ee3f16810c564216">setOnExitTransitionDidStartCallback</a> (const std::function&lt; void()&gt; &amp;callback)</td></tr>
<tr class="memdesc:a493b56ca2e501911ee3f16810c564216 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the callback of event ExitTransitionDidStart.  <br /></td></tr>
<tr class="separator:a493b56ca2e501911ee3f16810c564216 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd288c2e9827c4fe4e4eb7e73d411d6c inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void()&gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#acd288c2e9827c4fe4e4eb7e73d411d6c">getOnExitTransitionDidStartCallback</a> () const</td></tr>
<tr class="memdesc:acd288c2e9827c4fe4e4eb7e73d411d6c inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the callback of event ExitTransitionDidStart.  <br /></td></tr>
<tr class="separator:acd288c2e9827c4fe4e4eb7e73d411d6c inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf29c73b2112b4d3e9231f0d94fa2101 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">
unsigned short&#160;</td><td class="memItemRight" valign="bottom"><b>getCameraMask</b> () const</td></tr>
<tr class="memdesc:adf29c73b2112b4d3e9231f0d94fa2101 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">get &amp; set camera mask, the node is visible by the camera whose camera flag &amp; node's camera mask is true <br /></td></tr>
<tr class="separator:adf29c73b2112b4d3e9231f0d94fa2101 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f6f9d8c9350dbae9852ea97f0c9a82 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a74f6f9d8c9350dbae9852ea97f0c9a82">setCameraMask</a> (unsigned short mask, bool applyChildren=true)</td></tr>
<tr class="memdesc:a74f6f9d8c9350dbae9852ea97f0c9a82 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify the camera mask for current node.  <br /></td></tr>
<tr class="separator:a74f6f9d8c9350dbae9852ea97f0c9a82 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c100ee1c82f83bccc2ae3b75bf325fe inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a4c100ee1c82f83bccc2ae3b75bf325fe">applyMaskOnEnter</a> (bool applyChildren)</td></tr>
<tr class="memdesc:a4c100ee1c82f83bccc2ae3b75bf325fe inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should <a class="el" href="../../df/da2/classax_1_1_node.html#aaa1f21f77c26adee1ce1444b31c69178" title="Adds a child to the container with z-order as 0.">addChild()</a> make the child follow it's parent's mask? If applyChildren is true, then it will modify the camera mask of its children recursively when a child is added.  <br /></td></tr>
<tr class="separator:a4c100ee1c82f83bccc2ae3b75bf325fe inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f9c73506155c89a1a785cf2f7718f0d inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a5f9c73506155c89a1a785cf2f7718f0d">setProgramState</a> (backend::ProgramState *programState, bool ownPS=false)</td></tr>
<tr class="memdesc:a5f9c73506155c89a1a785cf2f7718f0d inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets ProgramState with retain.  <br /></td></tr>
<tr class="separator:a5f9c73506155c89a1a785cf2f7718f0d inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffc75d55abdc1c3a65150e4dc2b32ff inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">backend::ProgramState *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a2ffc75d55abdc1c3a65150e4dc2b32ff">setProgramStateByProgramId</a> (uint64_t progId)</td></tr>
<tr class="memdesc:a2ffc75d55abdc1c3a65150e4dc2b32ff inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets ProgramState by programId.  <br /></td></tr>
<tr class="separator:a2ffc75d55abdc1c3a65150e4dc2b32ff inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30da2e2f84bf5dab27e7bf850ad80ec1 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a30da2e2f84bf5dab27e7bf850ad80ec1">setLocalZOrder</a> (int localZOrder)</td></tr>
<tr class="memdesc:a30da2e2f84bf5dab27e7bf850ad80ec1 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">LocalZOrder is the 'key' used to sort the node relative to its siblings.  <br /></td></tr>
<tr class="separator:a30da2e2f84bf5dab27e7bf850ad80ec1 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac704060aed4cd2ecd7089b386b82cf0a inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ac704060aed4cd2ecd7089b386b82cf0a">updateOrderOfArrival</a> ()</td></tr>
<tr class="memdesc:ac704060aed4cd2ecd7089b386b82cf0a inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">!!! ONLY FOR INTERNAL USE Sets the arrival order when this node has a same ZOrder with other children.  <br /></td></tr>
<tr class="separator:ac704060aed4cd2ecd7089b386b82cf0a inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ee3e2f46780f87ecbce0a11870f7c0 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a47ee3e2f46780f87ecbce0a11870f7c0">getLocalZOrder</a> () const</td></tr>
<tr class="memdesc:a47ee3e2f46780f87ecbce0a11870f7c0 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the local Z order of this node.  <br /></td></tr>
<tr class="separator:a47ee3e2f46780f87ecbce0a11870f7c0 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7800c6b2895e122954582bf624fb85b3 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a7800c6b2895e122954582bf624fb85b3">setGlobalZOrder</a> (float globalZOrder)</td></tr>
<tr class="memdesc:a7800c6b2895e122954582bf624fb85b3 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the order in which the nodes are renderer.  <br /></td></tr>
<tr class="separator:a7800c6b2895e122954582bf624fb85b3 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0725e8c04e4fd8779fc66c29c5fd01ca inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a0725e8c04e4fd8779fc66c29c5fd01ca">getGlobalZOrder</a> () const</td></tr>
<tr class="memdesc:a0725e8c04e4fd8779fc66c29c5fd01ca inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="../../df/da2/classax_1_1_node.html" title="Node is the base element of the Scene Graph.">Node</a>'s Global Z Order.  <br /></td></tr>
<tr class="separator:a0725e8c04e4fd8779fc66c29c5fd01ca inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7295c2bdcac8b28b2f333b83eb1e678 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ab7295c2bdcac8b28b2f333b83eb1e678">getScaleX</a> () const</td></tr>
<tr class="memdesc:ab7295c2bdcac8b28b2f333b83eb1e678 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scale factor on X axis of this node.  <br /></td></tr>
<tr class="separator:ab7295c2bdcac8b28b2f333b83eb1e678 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e6602898f2d25d02abc1da4ff400a5 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a00e6602898f2d25d02abc1da4ff400a5">getScaleY</a> () const</td></tr>
<tr class="memdesc:a00e6602898f2d25d02abc1da4ff400a5 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scale factor on Y axis of this node.  <br /></td></tr>
<tr class="separator:a00e6602898f2d25d02abc1da4ff400a5 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc0be8e3eb46148f9f4d06b0baa2c7c inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a7cc0be8e3eb46148f9f4d06b0baa2c7c">setScaleZ</a> (float scaleZ)</td></tr>
<tr class="memdesc:a7cc0be8e3eb46148f9f4d06b0baa2c7c inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the scale factor on Z axis of this node.  <br /></td></tr>
<tr class="separator:a7cc0be8e3eb46148f9f4d06b0baa2c7c inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8de71d5321fb2b91088eca7230731c8 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#af8de71d5321fb2b91088eca7230731c8">getScaleZ</a> () const</td></tr>
<tr class="memdesc:af8de71d5321fb2b91088eca7230731c8 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the scale factor on Z axis of this node.  <br /></td></tr>
<tr class="separator:af8de71d5321fb2b91088eca7230731c8 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c24eca5da61bda84619024cdcd1b9c inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ab0c24eca5da61bda84619024cdcd1b9c">getScale</a> () const</td></tr>
<tr class="memdesc:ab0c24eca5da61bda84619024cdcd1b9c inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the scale factor of the node, when X and Y have the same scale factor.  <br /></td></tr>
<tr class="separator:ab0c24eca5da61bda84619024cdcd1b9c inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6be2ddba6bb3ba59e29f6e43722268 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#aef6be2ddba6bb3ba59e29f6e43722268">setPositionNormalized</a> (const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;position)</td></tr>
<tr class="memdesc:aef6be2ddba6bb3ba59e29f6e43722268 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position (x,y) using values between 0 and 1.  <br /></td></tr>
<tr class="separator:aef6be2ddba6bb3ba59e29f6e43722268 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e42bc88b88fd933c13ac2c0f11f558 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ae6e42bc88b88fd933c13ac2c0f11f558">getPosition</a> () const</td></tr>
<tr class="memdesc:ae6e42bc88b88fd933c13ac2c0f11f558 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the position (x,y) of the node in its parent's coordinate system.  <br /></td></tr>
<tr class="separator:ae6e42bc88b88fd933c13ac2c0f11f558 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad937b3deec2bc9f0986955395a1521ae inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ad937b3deec2bc9f0986955395a1521ae">getPositionNormalized</a> () const</td></tr>
<tr class="memdesc:ad937b3deec2bc9f0986955395a1521ae inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the normalized position.  <br /></td></tr>
<tr class="separator:ad937b3deec2bc9f0986955395a1521ae inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c81388ec2cedada0895e4e1543aefdc inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a4c81388ec2cedada0895e4e1543aefdc">getPosition</a> (float *x, float *y) const</td></tr>
<tr class="memdesc:a4c81388ec2cedada0895e4e1543aefdc inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets position in a more efficient way, returns two number instead of a <a class="el" href="../../d3/d6f/classax_1_1_vec2.html" title="Defines a 2-element floating point vector.">Vec2</a> object.  <br /></td></tr>
<tr class="separator:a4c81388ec2cedada0895e4e1543aefdc inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcb14b683855bac1f966fb9cda7263c inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#abdcb14b683855bac1f966fb9cda7263c">setPositionX</a> (float x)</td></tr>
<tr class="memdesc:abdcb14b683855bac1f966fb9cda7263c inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets/Sets x or y coordinate individually for position.  <br /></td></tr>
<tr class="separator:abdcb14b683855bac1f966fb9cda7263c inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af5c1f88c6ac000e2503c25cf0d74f4 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a5af5c1f88c6ac000e2503c25cf0d74f4">getPositionX</a> () const</td></tr>
<tr class="memdesc:a5af5c1f88c6ac000e2503c25cf0d74f4 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the x coordinate of the node in its parent's coordinate system.  <br /></td></tr>
<tr class="separator:a5af5c1f88c6ac000e2503c25cf0d74f4 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce0171b2b65ff4b339fc5188c3f31d5 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a5ce0171b2b65ff4b339fc5188c3f31d5">setPositionY</a> (float y)</td></tr>
<tr class="memdesc:a5ce0171b2b65ff4b339fc5188c3f31d5 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the y coordinate of the node in its parent's coordinate system.  <br /></td></tr>
<tr class="separator:a5ce0171b2b65ff4b339fc5188c3f31d5 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f654365d487e1b0a067faba70915284 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a4f654365d487e1b0a067faba70915284">getPositionY</a> () const</td></tr>
<tr class="memdesc:a4f654365d487e1b0a067faba70915284 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the y coordinate of the node in its parent's coordinate system.  <br /></td></tr>
<tr class="separator:a4f654365d487e1b0a067faba70915284 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb95e8faaa333a1cae953a330598ca6e inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#adb95e8faaa333a1cae953a330598ca6e">setPosition3D</a> (const <a class="el" href="../../d0/de0/classax_1_1_vec3.html">Vec3</a> &amp;position)</td></tr>
<tr class="memdesc:adb95e8faaa333a1cae953a330598ca6e inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the position (X, Y, and Z) in its parent's coordinate system.  <br /></td></tr>
<tr class="separator:adb95e8faaa333a1cae953a330598ca6e inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c7eafd20f6c73be30f439500f30bd1 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d0/de0/classax_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ae3c7eafd20f6c73be30f439500f30bd1">getPosition3D</a> () const</td></tr>
<tr class="memdesc:ae3c7eafd20f6c73be30f439500f30bd1 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the position (X,Y,Z) in its parent's coordinate system.  <br /></td></tr>
<tr class="separator:ae3c7eafd20f6c73be30f439500f30bd1 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534468c827750bd6aba7f51bca3b4611 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a534468c827750bd6aba7f51bca3b4611">getPositionZ</a> () const</td></tr>
<tr class="memdesc:a534468c827750bd6aba7f51bca3b4611 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets position Z coordinate of this node.  <br /></td></tr>
<tr class="separator:a534468c827750bd6aba7f51bca3b4611 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd49bb2749cf00d8e1ea29f786af1bbe inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#afd49bb2749cf00d8e1ea29f786af1bbe">getSkewX</a> () const</td></tr>
<tr class="memdesc:afd49bb2749cf00d8e1ea29f786af1bbe inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the X skew angle of the node in degrees.  <br /></td></tr>
<tr class="separator:afd49bb2749cf00d8e1ea29f786af1bbe inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e8649908e6ca456d52fe217f2a3ad8 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ad6e8649908e6ca456d52fe217f2a3ad8">getSkewY</a> () const</td></tr>
<tr class="memdesc:ad6e8649908e6ca456d52fe217f2a3ad8 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Y skew angle of the node in degrees.  <br /></td></tr>
<tr class="separator:ad6e8649908e6ca456d52fe217f2a3ad8 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857c313c68300e49447c478744a18a80 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a857c313c68300e49447c478744a18a80">getAnchorPoint</a> () const</td></tr>
<tr class="memdesc:a857c313c68300e49447c478744a18a80 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the anchor point in percent.  <br /></td></tr>
<tr class="separator:a857c313c68300e49447c478744a18a80 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd9fefa842340dfc0b29e62789be537 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#aefd9fefa842340dfc0b29e62789be537">getAnchorPointInPoints</a> () const</td></tr>
<tr class="memdesc:aefd9fefa842340dfc0b29e62789be537 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the anchorPoint in absolute pixels.  <br /></td></tr>
<tr class="separator:aefd9fefa842340dfc0b29e62789be537 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b07714220524441c0443c8edc43400 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a48b07714220524441c0443c8edc43400">getContentSize</a> () const</td></tr>
<tr class="memdesc:a48b07714220524441c0443c8edc43400 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the untransformed size of the node.  <br /></td></tr>
<tr class="separator:a48b07714220524441c0443c8edc43400 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f14510179b750ebf5fc388661c2a0a6 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a6f14510179b750ebf5fc388661c2a0a6">hitTest</a> (const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;worldPoint) const</td></tr>
<tr class="memdesc:a6f14510179b750ebf5fc388661c2a0a6 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">The basic node hit test, since axmol-1.0.  <br /></td></tr>
<tr class="separator:a6f14510179b750ebf5fc388661c2a0a6 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9e092d80ed0c3995187866bb1b12e2 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#aaf9e092d80ed0c3995187866bb1b12e2">isVisible</a> () const</td></tr>
<tr class="memdesc:aaf9e092d80ed0c3995187866bb1b12e2 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the node is visible.  <br /></td></tr>
<tr class="separator:aaf9e092d80ed0c3995187866bb1b12e2 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b492a42beb4eb220c270b180e45d7a inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a77b492a42beb4eb220c270b180e45d7a">getRotation</a> () const</td></tr>
<tr class="memdesc:a77b492a42beb4eb220c270b180e45d7a inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rotation of the node in degrees.  <br /></td></tr>
<tr class="separator:a77b492a42beb4eb220c270b180e45d7a inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1b199afbb075836f043345648a8309 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a0e1b199afbb075836f043345648a8309">setRotation3D</a> (const <a class="el" href="../../d0/de0/classax_1_1_vec3.html">Vec3</a> &amp;rotation)</td></tr>
<tr class="memdesc:a0e1b199afbb075836f043345648a8309 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the rotation (X,Y,Z) in degrees.  <br /></td></tr>
<tr class="separator:a0e1b199afbb075836f043345648a8309 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5972c29144add8df05b85cdf74a33f5 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d0/de0/classax_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ac5972c29144add8df05b85cdf74a33f5">getRotation3D</a> () const</td></tr>
<tr class="memdesc:ac5972c29144add8df05b85cdf74a33f5 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rotation (X,Y,Z) in degrees.  <br /></td></tr>
<tr class="separator:ac5972c29144add8df05b85cdf74a33f5 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16071ecbd0c17d865e4dddcd76b5427a inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a16071ecbd0c17d865e4dddcd76b5427a">setRotationQuat</a> (const <a class="el" href="../../d7/da5/classax_1_1_quaternion.html">Quaternion</a> &amp;quat)</td></tr>
<tr class="memdesc:a16071ecbd0c17d865e4dddcd76b5427a inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set rotation by quaternion.  <br /></td></tr>
<tr class="separator:a16071ecbd0c17d865e4dddcd76b5427a inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c81eeb7eed877af0a368e226bca0ff1 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d7/da5/classax_1_1_quaternion.html">Quaternion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a8c81eeb7eed877af0a368e226bca0ff1">getRotationQuat</a> () const</td></tr>
<tr class="memdesc:a8c81eeb7eed877af0a368e226bca0ff1 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rotation by quaternion, Note that when _rotationZ_X == _rotationZ_Y, the returned quaternion equals to RotationZ_X * RotationY * RotationX, it equals to RotationY * RotationX otherwise.  <br /></td></tr>
<tr class="separator:a8c81eeb7eed877af0a368e226bca0ff1 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776fe02f7b38e35da0dd22ef311feab0 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a776fe02f7b38e35da0dd22ef311feab0">getRotationSkewX</a> () const</td></tr>
<tr class="memdesc:a776fe02f7b38e35da0dd22ef311feab0 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the X rotation (angle) of the node in degrees which performs a horizontal rotation skew.  <br /></td></tr>
<tr class="separator:a776fe02f7b38e35da0dd22ef311feab0 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a352dc55f4b91b55260a9de1c17a9125c inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a352dc55f4b91b55260a9de1c17a9125c">getRotationSkewY</a> () const</td></tr>
<tr class="memdesc:a352dc55f4b91b55260a9de1c17a9125c inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew.  <br /></td></tr>
<tr class="separator:a352dc55f4b91b55260a9de1c17a9125c inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4de468e77603062ca4663f7ffa5a8c inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a6c4de468e77603062ca4663f7ffa5a8c">isIgnoreAnchorPointForPosition</a> () const</td></tr>
<tr class="memdesc:a6c4de468e77603062ca4663f7ffa5a8c inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets whether the anchor point will be (0,0) when you position this node.  <br /></td></tr>
<tr class="separator:a6c4de468e77603062ca4663f7ffa5a8c inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adc3b1348beeb5762a3a08fbddd17d0 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a9adc3b1348beeb5762a3a08fbddd17d0">getTag</a> () const</td></tr>
<tr class="memdesc:a9adc3b1348beeb5762a3a08fbddd17d0 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a tag that is used to identify the node easily.  <br /></td></tr>
<tr class="separator:a9adc3b1348beeb5762a3a08fbddd17d0 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af833eb63c35974aff52d336565fd89cd inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#af833eb63c35974aff52d336565fd89cd">setTag</a> (int tag)</td></tr>
<tr class="memdesc:af833eb63c35974aff52d336565fd89cd inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the tag that is used to identify the node easily.  <br /></td></tr>
<tr class="separator:af833eb63c35974aff52d336565fd89cd inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2acfacf92a6e138399926ee7be705360 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual std::string_view&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a2acfacf92a6e138399926ee7be705360">getName</a> () const</td></tr>
<tr class="memdesc:a2acfacf92a6e138399926ee7be705360 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that is used to identify the node.  <br /></td></tr>
<tr class="separator:a2acfacf92a6e138399926ee7be705360 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520e50fff1b4409212df8624a2640e39 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a520e50fff1b4409212df8624a2640e39">setName</a> (std::string_view name)</td></tr>
<tr class="memdesc:a520e50fff1b4409212df8624a2640e39 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the name that is used to identify the node easily.  <br /></td></tr>
<tr class="separator:a520e50fff1b4409212df8624a2640e39 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df40ff931bfdfac2b9af3c103fa21c1 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a5df40ff931bfdfac2b9af3c103fa21c1">getUserData</a> ()</td></tr>
<tr class="memdesc:a5df40ff931bfdfac2b9af3c103fa21c1 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a custom user data pointer.  <br /></td></tr>
<tr class="separator:a5df40ff931bfdfac2b9af3c103fa21c1 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811ec2dc4ef84b6ed7c86058795779de inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">
virtual const void *&#160;</td><td class="memItemRight" valign="bottom"><b>getUserData</b> () const</td></tr>
<tr class="memdesc:a811ec2dc4ef84b6ed7c86058795779de inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">@lua NA <br /></td></tr>
<tr class="separator:a811ec2dc4ef84b6ed7c86058795779de inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a0a018529a356b1a20ccc5d3508a1a inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a38a0a018529a356b1a20ccc5d3508a1a">setUserData</a> (void *userData)</td></tr>
<tr class="memdesc:a38a0a018529a356b1a20ccc5d3508a1a inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a custom user data pointer.  <br /></td></tr>
<tr class="separator:a38a0a018529a356b1a20ccc5d3508a1a inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fa0bec7180926be1a3a57a4a6db8f0 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d0/d25/classax_1_1_object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a18fa0bec7180926be1a3a57a4a6db8f0">getUserObject</a> ()</td></tr>
<tr class="memdesc:a18fa0bec7180926be1a3a57a4a6db8f0 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a user assigned <a class="el" href="../../d0/d25/classax_1_1_object.html" title="Object is used for reference count management.">Object</a>.  <br /></td></tr>
<tr class="separator:a18fa0bec7180926be1a3a57a4a6db8f0 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5a04d9231e7cee71bdc2a7ef125a54 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">
virtual const <a class="el" href="../../d0/d25/classax_1_1_object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getUserObject</b> () const</td></tr>
<tr class="memdesc:a4d5a04d9231e7cee71bdc2a7ef125a54 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">@lua NA <br /></td></tr>
<tr class="separator:a4d5a04d9231e7cee71bdc2a7ef125a54 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7508cd6b74bde129fc290e74867824 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a8b7508cd6b74bde129fc290e74867824">setUserObject</a> (<a class="el" href="../../d0/d25/classax_1_1_object.html">Object</a> *userObject)</td></tr>
<tr class="memdesc:a8b7508cd6b74bde129fc290e74867824 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a user assigned <a class="el" href="../../d0/d25/classax_1_1_object.html" title="Object is used for reference count management.">Object</a>.  <br /></td></tr>
<tr class="separator:a8b7508cd6b74bde129fc290e74867824 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135d564e74970534bdcc703252f05ef3 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a135d564e74970534bdcc703252f05ef3">onEnter</a> ()</td></tr>
<tr class="memdesc:a135d564e74970534bdcc703252f05ef3 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/db6/classax_1_1_event.html" title="Base class of all kinds of events.">Event</a> callback that is invoked every time when <a class="el" href="../../df/da2/classax_1_1_node.html" title="Node is the base element of the Scene Graph.">Node</a> enters the 'stage'.  <br /></td></tr>
<tr class="separator:a135d564e74970534bdcc703252f05ef3 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ecc243090bd42aa514f0df65848f588 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a9ecc243090bd42aa514f0df65848f588">onEnterTransitionDidFinish</a> ()</td></tr>
<tr class="memdesc:a9ecc243090bd42aa514f0df65848f588 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/db6/classax_1_1_event.html" title="Base class of all kinds of events.">Event</a> callback that is invoked when the <a class="el" href="../../df/da2/classax_1_1_node.html" title="Node is the base element of the Scene Graph.">Node</a> enters in the 'stage'.  <br /></td></tr>
<tr class="separator:a9ecc243090bd42aa514f0df65848f588 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11ad620f620798fb4cf107a06ed4dba inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ad11ad620f620798fb4cf107a06ed4dba">onExit</a> ()</td></tr>
<tr class="memdesc:ad11ad620f620798fb4cf107a06ed4dba inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/db6/classax_1_1_event.html" title="Base class of all kinds of events.">Event</a> callback that is invoked every time the <a class="el" href="../../df/da2/classax_1_1_node.html" title="Node is the base element of the Scene Graph.">Node</a> leaves the 'stage'.  <br /></td></tr>
<tr class="separator:ad11ad620f620798fb4cf107a06ed4dba inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33cb6888a2cb30ccf3164e3def6e1ad inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ab33cb6888a2cb30ccf3164e3def6e1ad">onExitTransitionDidStart</a> ()</td></tr>
<tr class="memdesc:ab33cb6888a2cb30ccf3164e3def6e1ad inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d5/db6/classax_1_1_event.html" title="Base class of all kinds of events.">Event</a> callback that is called every time the <a class="el" href="../../df/da2/classax_1_1_node.html" title="Node is the base element of the Scene Graph.">Node</a> leaves the 'stage'.  <br /></td></tr>
<tr class="separator:ab33cb6888a2cb30ccf3164e3def6e1ad inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef7f2a387dbcc4f024247a8c916979f inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a4ef7f2a387dbcc4f024247a8c916979f">setActionManager</a> (<a class="el" href="../../d0/d21/classax_1_1_action_manager.html">ActionManager</a> *actionManager)</td></tr>
<tr class="memdesc:a4ef7f2a387dbcc4f024247a8c916979f inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="../../d0/d21/classax_1_1_action_manager.html" title="ActionManager is a singleton that manages all the actions.">ActionManager</a> object that is used by all actions.  <br /></td></tr>
<tr class="separator:a4ef7f2a387dbcc4f024247a8c916979f inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54b0914fe02ad97a21a77c343a42458 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d0/d21/classax_1_1_action_manager.html">ActionManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ac54b0914fe02ad97a21a77c343a42458">getActionManager</a> ()</td></tr>
<tr class="memdesc:ac54b0914fe02ad97a21a77c343a42458 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the <a class="el" href="../../d0/d21/classax_1_1_action_manager.html" title="ActionManager is a singleton that manages all the actions.">ActionManager</a> object that is used by all actions.  <br /></td></tr>
<tr class="separator:ac54b0914fe02ad97a21a77c343a42458 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cea1d09f1eab385ec4afca3eb96253b inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d2/db7/classax_1_1_action.html">Action</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a2cea1d09f1eab385ec4afca3eb96253b">runAction</a> (<a class="el" href="../../d2/db7/classax_1_1_action.html">Action</a> *action)</td></tr>
<tr class="memdesc:a2cea1d09f1eab385ec4afca3eb96253b inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes an action, and returns the action that is executed.  <br /></td></tr>
<tr class="separator:a2cea1d09f1eab385ec4afca3eb96253b inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac933485f6cc2b262dcd8b13baa020a34 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><b>stopAllActions</b> ()</td></tr>
<tr class="memdesc:ac933485f6cc2b262dcd8b13baa020a34 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops and removes all actions from the running action list . <br /></td></tr>
<tr class="separator:ac933485f6cc2b262dcd8b13baa020a34 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba6d673bdcca61f9be9b5bae0f13bfb inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#aeba6d673bdcca61f9be9b5bae0f13bfb">stopAction</a> (<a class="el" href="../../d2/db7/classax_1_1_action.html">Action</a> *action)</td></tr>
<tr class="memdesc:aeba6d673bdcca61f9be9b5bae0f13bfb inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops and removes an action from the running action list.  <br /></td></tr>
<tr class="separator:aeba6d673bdcca61f9be9b5bae0f13bfb inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2ba3025a3844622fbb9aed476b4e01 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a4b2ba3025a3844622fbb9aed476b4e01">stopActionByTag</a> (int tag)</td></tr>
<tr class="memdesc:a4b2ba3025a3844622fbb9aed476b4e01 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an action from the running action list by its tag.  <br /></td></tr>
<tr class="separator:a4b2ba3025a3844622fbb9aed476b4e01 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34a372fdd29ad6b530f272af9bad346 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#aa34a372fdd29ad6b530f272af9bad346">stopAllActionsByTag</a> (int tag)</td></tr>
<tr class="memdesc:aa34a372fdd29ad6b530f272af9bad346 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all actions from the running action list by its tag.  <br /></td></tr>
<tr class="separator:aa34a372fdd29ad6b530f272af9bad346 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4cc19eb687d35b3401affc87afb97c inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a4a4cc19eb687d35b3401affc87afb97c">stopActionsByFlags</a> (unsigned int flags)</td></tr>
<tr class="memdesc:a4a4cc19eb687d35b3401affc87afb97c inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all actions from the running action list by its flags.  <br /></td></tr>
<tr class="separator:a4a4cc19eb687d35b3401affc87afb97c inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b69e05519e283bdfb0eb3b1e555f8ac inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d2/db7/classax_1_1_action.html">Action</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a3b69e05519e283bdfb0eb3b1e555f8ac">getActionByTag</a> (int tag)</td></tr>
<tr class="memdesc:a3b69e05519e283bdfb0eb3b1e555f8ac inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets an action from the running action list by its tag.  <br /></td></tr>
<tr class="separator:a3b69e05519e283bdfb0eb3b1e555f8ac inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2fa7a17161bf3a4e84a1beb7edc90d inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a3d2fa7a17161bf3a4e84a1beb7edc90d">getNumberOfRunningActions</a> () const</td></tr>
<tr class="memdesc:a3d2fa7a17161bf3a4e84a1beb7edc90d inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the numbers of actions that are running plus the ones that are schedule to run (actions in actionsToAdd and actions arrays).  <br /></td></tr>
<tr class="separator:a3d2fa7a17161bf3a4e84a1beb7edc90d inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b44cd9e8246893ac10df563dfd66ee0 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a2b44cd9e8246893ac10df563dfd66ee0">getNumberOfRunningActionsByTag</a> (int tag) const</td></tr>
<tr class="memdesc:a2b44cd9e8246893ac10df563dfd66ee0 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the numbers of actions that are running plus the ones that are schedule to run (actions in actionsToAdd and actions arrays) with a specific tag.  <br /></td></tr>
<tr class="separator:a2b44cd9e8246893ac10df563dfd66ee0 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0d68d26ea0218be678e7e5ffee935d inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#afa0d68d26ea0218be678e7e5ffee935d">setScheduler</a> (<a class="el" href="../../db/dfa/classax_1_1_scheduler.html">Scheduler</a> *scheduler)</td></tr>
<tr class="memdesc:afa0d68d26ea0218be678e7e5ffee935d inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a <a class="el" href="../../db/dfa/classax_1_1_scheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks.">Scheduler</a> object that is used to schedule all "updates" and timers.  <br /></td></tr>
<tr class="separator:afa0d68d26ea0218be678e7e5ffee935d inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f05f8b649d5d8ceaf5fec28146a417 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../db/dfa/classax_1_1_scheduler.html">Scheduler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ac8f05f8b649d5d8ceaf5fec28146a417">getScheduler</a> ()</td></tr>
<tr class="memdesc:ac8f05f8b649d5d8ceaf5fec28146a417 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a <a class="el" href="../../db/dfa/classax_1_1_scheduler.html" title="Scheduler is responsible for triggering the scheduled callbacks.">Scheduler</a> object.  <br /></td></tr>
<tr class="separator:ac8f05f8b649d5d8ceaf5fec28146a417 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affbf901c0f92f490742728d0b839f1b5 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#affbf901c0f92f490742728d0b839f1b5">isScheduled</a> (SEL_SCHEDULE selector) const</td></tr>
<tr class="memdesc:affbf901c0f92f490742728d0b839f1b5 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a selector is scheduled.  <br /></td></tr>
<tr class="separator:affbf901c0f92f490742728d0b839f1b5 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917d3fc92121d1a666287e803ab393ea inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a917d3fc92121d1a666287e803ab393ea">isScheduled</a> (std::string_view key) const</td></tr>
<tr class="memdesc:a917d3fc92121d1a666287e803ab393ea inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether a lambda function is scheduled.  <br /></td></tr>
<tr class="separator:a917d3fc92121d1a666287e803ab393ea inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f246760e234fcdb5b3916fed9ec3943 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a2f246760e234fcdb5b3916fed9ec3943">scheduleUpdate</a> ()</td></tr>
<tr class="memdesc:a2f246760e234fcdb5b3916fed9ec3943 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules the "update" method.  <br /></td></tr>
<tr class="separator:a2f246760e234fcdb5b3916fed9ec3943 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0644b10a42366b9ef4efc24c71e1bd22 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a0644b10a42366b9ef4efc24c71e1bd22">scheduleUpdateWithPriority</a> (int priority)</td></tr>
<tr class="memdesc:a0644b10a42366b9ef4efc24c71e1bd22 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules the "update" method with a custom priority.  <br /></td></tr>
<tr class="separator:a0644b10a42366b9ef4efc24c71e1bd22 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa0df52e790f26ad723af12229dbd8e inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a1fa0df52e790f26ad723af12229dbd8e">schedule</a> (SEL_SCHEDULE selector, float interval, unsigned int repeat, float delay)</td></tr>
<tr class="memdesc:a1fa0df52e790f26ad723af12229dbd8e inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a custom selector.  <br /></td></tr>
<tr class="separator:a1fa0df52e790f26ad723af12229dbd8e inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6ad4371d8577656e7fd2c5a23316f5 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a8f6ad4371d8577656e7fd2c5a23316f5">schedule</a> (SEL_SCHEDULE selector, float interval)</td></tr>
<tr class="memdesc:a8f6ad4371d8577656e7fd2c5a23316f5 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a custom selector with an interval time in seconds.  <br /></td></tr>
<tr class="separator:a8f6ad4371d8577656e7fd2c5a23316f5 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c289b99af0683cc84b3ce96cdcd876 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#aa5c289b99af0683cc84b3ce96cdcd876">scheduleOnce</a> (SEL_SCHEDULE selector, float delay)</td></tr>
<tr class="memdesc:aa5c289b99af0683cc84b3ce96cdcd876 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a selector that runs only once, with a delay of 0 or larger.  <br /></td></tr>
<tr class="separator:aa5c289b99af0683cc84b3ce96cdcd876 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278b88299147018b723d3a8c12639c5f inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a278b88299147018b723d3a8c12639c5f">scheduleOnce</a> (const std::function&lt; void(float)&gt; &amp;callback, float delay, std::string_view key)</td></tr>
<tr class="memdesc:a278b88299147018b723d3a8c12639c5f inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a lambda function that runs only once, with a delay of 0 or larger.  <br /></td></tr>
<tr class="separator:a278b88299147018b723d3a8c12639c5f inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201de3de18ef592a3dd7564bbe449117 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a201de3de18ef592a3dd7564bbe449117">schedule</a> (SEL_SCHEDULE selector)</td></tr>
<tr class="memdesc:a201de3de18ef592a3dd7564bbe449117 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a custom selector, the scheduled selector will be ticked every frame.  <br /></td></tr>
<tr class="separator:a201de3de18ef592a3dd7564bbe449117 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14aba14256ea4237e8c6a3f5e67f8310 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a14aba14256ea4237e8c6a3f5e67f8310">schedule</a> (const std::function&lt; void(float)&gt; &amp;callback, std::string_view key)</td></tr>
<tr class="memdesc:a14aba14256ea4237e8c6a3f5e67f8310 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a lambda function.  <br /></td></tr>
<tr class="separator:a14aba14256ea4237e8c6a3f5e67f8310 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630320d8e255e6a1fb41cde4b08f5622 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a630320d8e255e6a1fb41cde4b08f5622">schedule</a> (const std::function&lt; void(float)&gt; &amp;callback, float interval, std::string_view key)</td></tr>
<tr class="memdesc:a630320d8e255e6a1fb41cde4b08f5622 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a lambda function.  <br /></td></tr>
<tr class="separator:a630320d8e255e6a1fb41cde4b08f5622 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a944496e4a34c99416426b594d043f745 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a944496e4a34c99416426b594d043f745">schedule</a> (const std::function&lt; void(float)&gt; &amp;callback, float interval, unsigned int repeat, float delay, std::string_view key)</td></tr>
<tr class="memdesc:a944496e4a34c99416426b594d043f745 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedules a lambda function.  <br /></td></tr>
<tr class="separator:a944496e4a34c99416426b594d043f745 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fa7db85e4ba9f95633a348daf70c98 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ae3fa7db85e4ba9f95633a348daf70c98">unschedule</a> (SEL_SCHEDULE selector)</td></tr>
<tr class="memdesc:ae3fa7db85e4ba9f95633a348daf70c98 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unschedules a custom selector.  <br /></td></tr>
<tr class="separator:ae3fa7db85e4ba9f95633a348daf70c98 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ad95e7a42ebcdb3a55a74c94132d8e5 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a5ad95e7a42ebcdb3a55a74c94132d8e5">unschedule</a> (std::string_view key)</td></tr>
<tr class="memdesc:a5ad95e7a42ebcdb3a55a74c94132d8e5 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unschedules a lambda function.  <br /></td></tr>
<tr class="separator:a5ad95e7a42ebcdb3a55a74c94132d8e5 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1689d5f38348260cf8731ae8157c1b2b inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a1689d5f38348260cf8731ae8157c1b2b">unscheduleAllCallbacks</a> ()</td></tr>
<tr class="memdesc:a1689d5f38348260cf8731ae8157c1b2b inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unschedule all scheduled selectors and lambda functions: custom selectors, and the 'update' selector and lambda functions.  <br /></td></tr>
<tr class="separator:a1689d5f38348260cf8731ae8157c1b2b inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8750549de4ce3be3cc5608b423204283 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a8750549de4ce3be3cc5608b423204283">resume</a> ()</td></tr>
<tr class="memdesc:a8750549de4ce3be3cc5608b423204283 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes all scheduled selectors, actions and event listeners.  <br /></td></tr>
<tr class="separator:a8750549de4ce3be3cc5608b423204283 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468fe2136e366509514bb38fed9d0102 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a468fe2136e366509514bb38fed9d0102">pause</a> ()</td></tr>
<tr class="memdesc:a468fe2136e366509514bb38fed9d0102 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pauses all scheduled selectors, actions and event listeners.  <br /></td></tr>
<tr class="separator:a468fe2136e366509514bb38fed9d0102 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b92c144ab3892e02e4d084fcf55e0e inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ab2b92c144ab3892e02e4d084fcf55e0e">update</a> (float delta)</td></tr>
<tr class="memdesc:ab2b92c144ab3892e02e4d084fcf55e0e inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update method will be called automatically every frame if "scheduleUpdate" is called, and the node is "live".  <br /></td></tr>
<tr class="separator:ab2b92c144ab3892e02e4d084fcf55e0e inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44c8295955d1ea2c140c8d93dae08b8 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d8/d6e/classax_1_1_mat4.html">Mat4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ac44c8295955d1ea2c140c8d93dae08b8">getNodeToParentTransform</a> () const</td></tr>
<tr class="memdesc:ac44c8295955d1ea2c140c8d93dae08b8 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matrix that transform the node's (local) space coordinates into the parent's space coordinates.  <br /></td></tr>
<tr class="separator:ac44c8295955d1ea2c140c8d93dae08b8 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30416b59d4fef6a91fbdde2f8c94a1a inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d8/d6e/classax_1_1_mat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#aa30416b59d4fef6a91fbdde2f8c94a1a">getNodeToParentTransform</a> (<a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *ancestor) const</td></tr>
<tr class="memdesc:aa30416b59d4fef6a91fbdde2f8c94a1a inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matrix that transform the node's (local) space coordinates into the parent's space coordinates.  <br /></td></tr>
<tr class="separator:aa30416b59d4fef6a91fbdde2f8c94a1a inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5533728ba6611986a0c946bfa297a5c4 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../df/ddd/structax_1_1_affine_transform.html">AffineTransform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a5533728ba6611986a0c946bfa297a5c4">getNodeToParentAffineTransform</a> (<a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *ancestor) const</td></tr>
<tr class="memdesc:a5533728ba6611986a0c946bfa297a5c4 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the affine transform matrix that transform the node's (local) space coordinates into the parent's space coordinates.  <br /></td></tr>
<tr class="separator:a5533728ba6611986a0c946bfa297a5c4 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c64ad7818c97e01c38a431535da9a9 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a93c64ad7818c97e01c38a431535da9a9">setNodeToParentTransform</a> (const <a class="el" href="../../d8/d6e/classax_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="memdesc:a93c64ad7818c97e01c38a431535da9a9 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the transformation matrix manually.  <br /></td></tr>
<tr class="separator:a93c64ad7818c97e01c38a431535da9a9 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88c5d594d657d3f51e87e07f66822589 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="../../d8/d6e/classax_1_1_mat4.html">Mat4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a88c5d594d657d3f51e87e07f66822589">getParentToNodeTransform</a> () const</td></tr>
<tr class="memdesc:a88c5d594d657d3f51e87e07f66822589 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the matrix that transform parent's space coordinates to the node's (local) space coordinates.  <br /></td></tr>
<tr class="separator:a88c5d594d657d3f51e87e07f66822589 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90981c4ab35d17ed5a64b0961e50d244 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d8/d6e/classax_1_1_mat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a90981c4ab35d17ed5a64b0961e50d244">getNodeToWorldTransform</a> () const</td></tr>
<tr class="memdesc:a90981c4ab35d17ed5a64b0961e50d244 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the world affine transform matrix.  <br /></td></tr>
<tr class="separator:a90981c4ab35d17ed5a64b0961e50d244 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306ea92593928ff39952d9772b9c072e inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../d8/d6e/classax_1_1_mat4.html">Mat4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a306ea92593928ff39952d9772b9c072e">getWorldToNodeTransform</a> () const</td></tr>
<tr class="memdesc:a306ea92593928ff39952d9772b9c072e inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse world affine transform matrix.  <br /></td></tr>
<tr class="separator:a306ea92593928ff39952d9772b9c072e inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87ae74d97bcf82d7e963d52848c7b0d inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#aa87ae74d97bcf82d7e963d52848c7b0d">convertToNodeSpace</a> (const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;worldPoint) const</td></tr>
<tr class="memdesc:aa87ae74d97bcf82d7e963d52848c7b0d inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="../../d3/d6f/classax_1_1_vec2.html" title="Defines a 2-element floating point vector.">Vec2</a> to node (local) space coordinates.  <br /></td></tr>
<tr class="separator:aa87ae74d97bcf82d7e963d52848c7b0d inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc9bd4bfa3a632666054886fe4fefc1 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#afcc9bd4bfa3a632666054886fe4fefc1">convertToWorldSpace</a> (const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;nodePoint) const</td></tr>
<tr class="memdesc:afcc9bd4bfa3a632666054886fe4fefc1 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="../../d3/d6f/classax_1_1_vec2.html" title="Defines a 2-element floating point vector.">Vec2</a> to world space coordinates.  <br /></td></tr>
<tr class="separator:afcc9bd4bfa3a632666054886fe4fefc1 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2052ebb81d0817ed656dbb1aff86f84 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ae2052ebb81d0817ed656dbb1aff86f84">convertToNodeSpaceAR</a> (const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;worldPoint) const</td></tr>
<tr class="memdesc:ae2052ebb81d0817ed656dbb1aff86f84 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="../../d3/d6f/classax_1_1_vec2.html" title="Defines a 2-element floating point vector.">Vec2</a> to node (local) space coordinates.  <br /></td></tr>
<tr class="separator:ae2052ebb81d0817ed656dbb1aff86f84 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a39009611aebe70f3def7acd63d4382 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a7a39009611aebe70f3def7acd63d4382">convertToWorldSpaceAR</a> (const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;nodePoint) const</td></tr>
<tr class="memdesc:a7a39009611aebe70f3def7acd63d4382 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a local <a class="el" href="../../d3/d6f/classax_1_1_vec2.html" title="Defines a 2-element floating point vector.">Vec2</a> to world space coordinates.The result is in Points.  <br /></td></tr>
<tr class="separator:a7a39009611aebe70f3def7acd63d4382 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace01164ec8da1fcc5c213d6fca2eb238 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ace01164ec8da1fcc5c213d6fca2eb238">convertTouchToNodeSpace</a> (<a class="el" href="../../d8/de9/classax_1_1_touch.html">Touch</a> *touch) const</td></tr>
<tr class="memdesc:ace01164ec8da1fcc5c213d6fca2eb238 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience methods which take a <a class="el" href="../../d8/de9/classax_1_1_touch.html" title="Encapsulates the Touch information, such as touch point, id and so on, and provides the methods that ...">Touch</a> instead of <a class="el" href="../../d3/d6f/classax_1_1_vec2.html" title="Defines a 2-element floating point vector.">Vec2</a>.  <br /></td></tr>
<tr class="separator:ace01164ec8da1fcc5c213d6fca2eb238 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67a73976e1e01e4ccd523933258d94a inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ab67a73976e1e01e4ccd523933258d94a">convertTouchToNodeSpaceAR</a> (<a class="el" href="../../d8/de9/classax_1_1_touch.html">Touch</a> *touch) const</td></tr>
<tr class="memdesc:ab67a73976e1e01e4ccd523933258d94a inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">converts a <a class="el" href="../../d8/de9/classax_1_1_touch.html" title="Encapsulates the Touch information, such as touch point, id and so on, and provides the methods that ...">Touch</a> (world coordinates) into a local coordinate.  <br /></td></tr>
<tr class="separator:ab67a73976e1e01e4ccd523933258d94a inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79a7bc936ca1ac376870d35f666a97d inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ac79a7bc936ca1ac376870d35f666a97d">getWorldPosition</a> () const</td></tr>
<tr class="memdesc:ac79a7bc936ca1ac376870d35f666a97d inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets position of node in world space.  <br /></td></tr>
<tr class="separator:ac79a7bc936ca1ac376870d35f666a97d inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb3f15321aaa839d161b922e89b2b71a inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#afb3f15321aaa839d161b922e89b2b71a">setWorldPosition</a> (const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;position)</td></tr>
<tr class="memdesc:afb3f15321aaa839d161b922e89b2b71a inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets position of node in world space.  <br /></td></tr>
<tr class="separator:afb3f15321aaa839d161b922e89b2b71a inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeebed7f1a9a6e6e52af4acf7c814fc8 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#aeeebed7f1a9a6e6e52af4acf7c814fc8">setAdditionalTransform</a> (const <a class="el" href="../../d8/d6e/classax_1_1_mat4.html">Mat4</a> *additionalTransform)</td></tr>
<tr class="memdesc:aeeebed7f1a9a6e6e52af4acf7c814fc8 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an additional transform matrix to the node.  <br /></td></tr>
<tr class="separator:aeeebed7f1a9a6e6e52af4acf7c814fc8 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab894481a7f0e2a1efc7e5f3a9db990 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">Component *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#aaab894481a7f0e2a1efc7e5f3a9db990">getComponent</a> (std::string_view name)</td></tr>
<tr class="memdesc:aaab894481a7f0e2a1efc7e5f3a9db990 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a component by its name.  <br /></td></tr>
<tr class="separator:aaab894481a7f0e2a1efc7e5f3a9db990 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e214dc65caae92b3111e6d31007fd8 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a78e214dc65caae92b3111e6d31007fd8">addComponent</a> (Component *component)</td></tr>
<tr class="memdesc:a78e214dc65caae92b3111e6d31007fd8 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a component.  <br /></td></tr>
<tr class="separator:a78e214dc65caae92b3111e6d31007fd8 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30419c10c56fd3a0bb7e2444ff9c8509 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a30419c10c56fd3a0bb7e2444ff9c8509">removeComponent</a> (std::string_view name)</td></tr>
<tr class="memdesc:a30419c10c56fd3a0bb7e2444ff9c8509 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a component by its name.  <br /></td></tr>
<tr class="separator:a30419c10c56fd3a0bb7e2444ff9c8509 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9efa26b9c27a1468d36024dd115a0d inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#abc9efa26b9c27a1468d36024dd115a0d">removeComponent</a> (Component *component)</td></tr>
<tr class="memdesc:abc9efa26b9c27a1468d36024dd115a0d inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a component by its pointer.  <br /></td></tr>
<tr class="separator:abc9efa26b9c27a1468d36024dd115a0d inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd5e64b59ec1d9059433f96144ea521 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>removeAllComponents</b> ()</td></tr>
<tr class="memdesc:a4fd5e64b59ec1d9059433f96144ea521 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all components. <br /></td></tr>
<tr class="separator:a4fd5e64b59ec1d9059433f96144ea521 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff42952b85c92c805f063d3fc0a951c7 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#aff42952b85c92c805f063d3fc0a951c7">getChildByTag</a> (int tag) const</td></tr>
<tr class="memdesc:aff42952b85c92c805f063d3fc0a951c7 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a child from the container with its tag.  <br /></td></tr>
<tr class="separator:aff42952b85c92c805f063d3fc0a951c7 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e30c4c73e674eb66c8312a36f0cb11 inherit pub_methods_classax_1_1_node"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7e30c4c73e674eb66c8312a36f0cb11 inherit pub_methods_classax_1_1_node"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ae7e30c4c73e674eb66c8312a36f0cb11">getChildByTag</a> (int tag) const</td></tr>
<tr class="memdesc:ae7e30c4c73e674eb66c8312a36f0cb11 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a child from the container with its tag that can be cast to Type T.  <br /></td></tr>
<tr class="separator:ae7e30c4c73e674eb66c8312a36f0cb11 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d41b791d0a744d6398b125adb609dec inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a6d41b791d0a744d6398b125adb609dec">getChildByName</a> (std::string_view name) const</td></tr>
<tr class="memdesc:a6d41b791d0a744d6398b125adb609dec inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a child from the container with its name.  <br /></td></tr>
<tr class="separator:a6d41b791d0a744d6398b125adb609dec inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9352370894640681ea717c8e826f2262 inherit pub_methods_classax_1_1_node"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9352370894640681ea717c8e826f2262 inherit pub_methods_classax_1_1_node"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a9352370894640681ea717c8e826f2262">getChildByName</a> (std::string_view name) const</td></tr>
<tr class="memdesc:a9352370894640681ea717c8e826f2262 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a child from the container with its name that can be cast to Type T.  <br /></td></tr>
<tr class="separator:a9352370894640681ea717c8e826f2262 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fea623c9a70653e0f136a3267657bbb inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a4fea623c9a70653e0f136a3267657bbb">enumerateChildren</a> (std::string_view name, std::function&lt; bool(<a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *node)&gt; callback) const</td></tr>
<tr class="memdesc:a4fea623c9a70653e0f136a3267657bbb inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the children of the receiving node to perform processing for nodes which share a name.  <br /></td></tr>
<tr class="separator:a4fea623c9a70653e0f136a3267657bbb inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc94d482e860ca954666d86de1584995 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual Vector&lt; <a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#afc94d482e860ca954666d86de1584995">getChildren</a> ()</td></tr>
<tr class="memdesc:afc94d482e860ca954666d86de1584995 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the array of the node's children.  <br /></td></tr>
<tr class="separator:afc94d482e860ca954666d86de1584995 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a226eb84553ed6a443553529a748142 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a9a226eb84553ed6a443553529a748142">getChildrenCount</a> () const</td></tr>
<tr class="memdesc:a9a226eb84553ed6a443553529a748142 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of children.  <br /></td></tr>
<tr class="separator:a9a226eb84553ed6a443553529a748142 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422bea9e2906683166604ca29884285e inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a422bea9e2906683166604ca29884285e">setParent</a> (<a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *parent)</td></tr>
<tr class="memdesc:a422bea9e2906683166604ca29884285e inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the parent node.  <br /></td></tr>
<tr class="separator:a422bea9e2906683166604ca29884285e inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9482308943ac550d8992e1746b29c0a1 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a9482308943ac550d8992e1746b29c0a1">getParent</a> ()</td></tr>
<tr class="memdesc:a9482308943ac550d8992e1746b29c0a1 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the parent node.  <br /></td></tr>
<tr class="separator:a9482308943ac550d8992e1746b29c0a1 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ae8e6cfb617d66b934e10dfc6f2bdc inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a56ae8e6cfb617d66b934e10dfc6f2bdc">removeFromParent</a> ()</td></tr>
<tr class="memdesc:a56ae8e6cfb617d66b934e10dfc6f2bdc inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes this node itself from its parent node with a cleanup.  <br /></td></tr>
<tr class="separator:a56ae8e6cfb617d66b934e10dfc6f2bdc inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5889948f4c40933e93aaf70cb8846192 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a5889948f4c40933e93aaf70cb8846192">removeFromParentAndCleanup</a> (bool <a class="el" href="../../df/da2/classax_1_1_node.html#a09f4fe805fa9a54d4d68c5b29c1502e1">cleanup</a>)</td></tr>
<tr class="memdesc:a5889948f4c40933e93aaf70cb8846192 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes this node itself from its parent node.  <br /></td></tr>
<tr class="separator:a5889948f4c40933e93aaf70cb8846192 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace46997bf90559d3f21dbf4135a79e89 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ace46997bf90559d3f21dbf4135a79e89">removeChildByTag</a> (int tag, bool <a class="el" href="../../df/da2/classax_1_1_node.html#a09f4fe805fa9a54d4d68c5b29c1502e1">cleanup</a>=true)</td></tr>
<tr class="memdesc:ace46997bf90559d3f21dbf4135a79e89 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a child from the container by tag value.  <br /></td></tr>
<tr class="separator:ace46997bf90559d3f21dbf4135a79e89 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ae64193944f00edcc86c26f917f509 inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a45ae64193944f00edcc86c26f917f509">removeChildByName</a> (std::string_view name, bool <a class="el" href="../../df/da2/classax_1_1_node.html#a09f4fe805fa9a54d4d68c5b29c1502e1">cleanup</a>=true)</td></tr>
<tr class="memdesc:a45ae64193944f00edcc86c26f917f509 inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a child from the container by tag value.  <br /></td></tr>
<tr class="separator:a45ae64193944f00edcc86c26f917f509 inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b173d1cc14489b3fd374e9b314bde1b inherit pub_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#a1b173d1cc14489b3fd374e9b314bde1b">removeAllChildren</a> ()</td></tr>
<tr class="memdesc:a1b173d1cc14489b3fd374e9b314bde1b inherit pub_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all children from the container with a cleanup.  <br /></td></tr>
<tr class="separator:a1b173d1cc14489b3fd374e9b314bde1b inherit pub_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classax_1_1_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classax_1_1_object')"><img src="../../closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="../../d0/d25/classax_1_1_object.html">Object</a></td></tr>
<tr class="memitem:a24888ae1fe9df2d329c9b485807cb62b inherit pub_methods_classax_1_1_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d25/classax_1_1_object.html#a24888ae1fe9df2d329c9b485807cb62b">retain</a> ()</td></tr>
<tr class="memdesc:a24888ae1fe9df2d329c9b485807cb62b inherit pub_methods_classax_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retains the ownership.  <br /></td></tr>
<tr class="separator:a24888ae1fe9df2d329c9b485807cb62b inherit pub_methods_classax_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b477d0e2d399f75d585d154c346591 inherit pub_methods_classax_1_1_object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d25/classax_1_1_object.html#a23b477d0e2d399f75d585d154c346591">release</a> ()</td></tr>
<tr class="memdesc:a23b477d0e2d399f75d585d154c346591 inherit pub_methods_classax_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the ownership immediately.  <br /></td></tr>
<tr class="separator:a23b477d0e2d399f75d585d154c346591 inherit pub_methods_classax_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c10c4318ad9f6d71f24f5185e4b8512 inherit pub_methods_classax_1_1_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d0/d25/classax_1_1_object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d25/classax_1_1_object.html#a8c10c4318ad9f6d71f24f5185e4b8512">autorelease</a> ()</td></tr>
<tr class="memdesc:a8c10c4318ad9f6d71f24f5185e4b8512 inherit pub_methods_classax_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the ownership sometime soon automatically.  <br /></td></tr>
<tr class="separator:a8c10c4318ad9f6d71f24f5185e4b8512 inherit pub_methods_classax_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f5c543c1504195eb40b1dcc4d1e794 inherit pub_methods_classax_1_1_object"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d25/classax_1_1_object.html#a00f5c543c1504195eb40b1dcc4d1e794">getReferenceCount</a> () const</td></tr>
<tr class="memdesc:a00f5c543c1504195eb40b1dcc4d1e794 inherit pub_methods_classax_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the <a class="el" href="../../d0/d25/classax_1_1_object.html" title="Object is used for reference count management.">Object</a>'s current reference count.  <br /></td></tr>
<tr class="separator:a00f5c543c1504195eb40b1dcc4d1e794 inherit pub_methods_classax_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cc4f9ba1ea5c2f25bc4b1f0dac5dc5 inherit pub_methods_classax_1_1_object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d25/classax_1_1_object.html#ab5cc4f9ba1ea5c2f25bc4b1f0dac5dc5">~Object</a> ()</td></tr>
<tr class="memdesc:ab5cc4f9ba1ea5c2f25bc4b1f0dac5dc5 inherit pub_methods_classax_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <br /></td></tr>
<tr class="separator:ab5cc4f9ba1ea5c2f25bc4b1f0dac5dc5 inherit pub_methods_classax_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a10eb179e1a192d301e5c275c7dd89042"><td class="memItemLeft" align="right" valign="top"><a id="a10eb179e1a192d301e5c275c7dd89042" name="a10eb179e1a192d301e5c275c7dd89042"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>INDEX_NOT_INITIALIZED</b> = -1</td></tr>
<tr class="memdesc:a10eb179e1a192d301e5c275c7dd89042"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a> invalid index on the <a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html" title="SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL c...">SpriteBatchNode</a>. <br /></td></tr>
<tr class="separator:a10eb179e1a192d301e5c275c7dd89042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classax_1_1_node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classax_1_1_node')"><img src="../../closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="../../df/da2/classax_1_1_node.html">Node</a></td></tr>
<tr class="memitem:a54e05d30a332e9faa9e25e182c7cb5ed inherit pub_static_attribs_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">
static const int&#160;</td><td class="memItemRight" valign="bottom"><b>INVALID_TAG</b> = -1</td></tr>
<tr class="memdesc:a54e05d30a332e9faa9e25e182c7cb5ed inherit pub_static_attribs_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default tag used for all the nodes. <br /></td></tr>
<tr class="separator:a54e05d30a332e9faa9e25e182c7cb5ed inherit pub_static_attribs_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Creators</h2></td></tr>
<tr class="memitem:aef8781bd993ff13b6e7b1fb792d33e20"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#aef8781bd993ff13b6e7b1fb792d33e20">create</a> ()</td></tr>
<tr class="memdesc:aef8781bd993ff13b6e7b1fb792d33e20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty sprite without texture.  <br /></td></tr>
<tr class="separator:aef8781bd993ff13b6e7b1fb792d33e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55e6b61026fd644e51e2876ed7706ed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#af55e6b61026fd644e51e2876ed7706ed">create</a> (std::string_view filename)</td></tr>
<tr class="memdesc:af55e6b61026fd644e51e2876ed7706ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sprite with an image filename.  <br /></td></tr>
<tr class="separator:af55e6b61026fd644e51e2876ed7706ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310ea446838da614aa3cee08d4d78a76"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a310ea446838da614aa3cee08d4d78a76">create</a> (const <a class="el" href="../../d6/d78/classax_1_1_polygon_info.html">PolygonInfo</a> &amp;info)</td></tr>
<tr class="memdesc:a310ea446838da614aa3cee08d4d78a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a polygon sprite with a polygon info.  <br /></td></tr>
<tr class="separator:a310ea446838da614aa3cee08d4d78a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa803de05042d0ff33057fbd5679c5864"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#aa803de05042d0ff33057fbd5679c5864">create</a> (std::string_view filename, const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="memdesc:aa803de05042d0ff33057fbd5679c5864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sprite with an image filename and a rect.  <br /></td></tr>
<tr class="separator:aa803de05042d0ff33057fbd5679c5864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af36336b69be450688dcf632c9c18ae4a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#af36336b69be450688dcf632c9c18ae4a">create</a> (const ax::Data &amp;imageData, std::string_view key)</td></tr>
<tr class="memdesc:af36336b69be450688dcf632c9c18ae4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sprite with an image data and an image key.  <br /></td></tr>
<tr class="separator:af36336b69be450688dcf632c9c18ae4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448e4f88b02d9583d2fac3c5c4d6f015"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a448e4f88b02d9583d2fac3c5c4d6f015">createWithTexture</a> (<a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html">Texture2D</a> *texture)</td></tr>
<tr class="memdesc:a448e4f88b02d9583d2fac3c5c4d6f015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sprite with a <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> object.  <br /></td></tr>
<tr class="separator:a448e4f88b02d9583d2fac3c5c4d6f015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78a23b92614c5ffb19698a72a8291dd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#af78a23b92614c5ffb19698a72a8291dd">createWithTexture</a> (<a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html">Texture2D</a> *texture, const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;rect, bool rotated=false)</td></tr>
<tr class="memdesc:af78a23b92614c5ffb19698a72a8291dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sprite with a texture and a rect.  <br /></td></tr>
<tr class="separator:af78a23b92614c5ffb19698a72a8291dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b1d3fce134f122d42ea525eb2b546cd"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#a5b1d3fce134f122d42ea525eb2b546cd">createWithSpriteFrame</a> (<a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html">SpriteFrame</a> *spriteFrame)</td></tr>
<tr class="memdesc:a5b1d3fce134f122d42ea525eb2b546cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sprite with an sprite frame.  <br /></td></tr>
<tr class="separator:a5b1d3fce134f122d42ea525eb2b546cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaabe681cb1669f98560ec876dfdea6e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d34/classax_1_1_sprite.html#acaabe681cb1669f98560ec876dfdea6e">createWithSpriteFrameName</a> (std::string_view spriteFrameName)</td></tr>
<tr class="memdesc:acaabe681cb1669f98560ec876dfdea6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a sprite with an sprite frame name.  <br /></td></tr>
<tr class="separator:acaabe681cb1669f98560ec876dfdea6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classax_1_1_node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classax_1_1_node')"><img src="../../closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="../../df/da2/classax_1_1_node.html">Node</a></td></tr>
<tr class="memitem:ac7a724506cb799fdcb5971717c72db94 inherit pub_static_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#ac7a724506cb799fdcb5971717c72db94">create</a> ()</td></tr>
<tr class="memdesc:ac7a724506cb799fdcb5971717c72db94 inherit pub_static_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and initializes a node.  <br /></td></tr>
<tr class="separator:ac7a724506cb799fdcb5971717c72db94 inherit pub_static_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fbf6dffb5e4aa88caa24229a364b51 inherit pub_static_methods_classax_1_1_node"><td class="memItemLeft" align="right" valign="top">
static int&#160;</td><td class="memItemRight" valign="bottom"><b>getAttachedNodeCount</b> ()</td></tr>
<tr class="memdesc:a59fbf6dffb5e4aa88caa24229a364b51 inherit pub_static_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets count of nodes those are attached to scene graph. <br /></td></tr>
<tr class="separator:a59fbf6dffb5e4aa88caa24229a364b51 inherit pub_static_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce3d41422fb5e7e3ead7a03f6e98cc1 inherit pub_static_methods_classax_1_1_node"><td class="memTemplParams" colspan="2">template&lt;typename _T &gt; </td></tr>
<tr class="memitem:acce3d41422fb5e7e3ead7a03f6e98cc1 inherit pub_static_methods_classax_1_1_node"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/da2/classax_1_1_node.html#acce3d41422fb5e7e3ead7a03f6e98cc1">sortNodes</a> (ax::Vector&lt; _T * &gt; &amp;nodes)</td></tr>
<tr class="memdesc:acce3d41422fb5e7e3ead7a03f6e98cc1 inherit pub_static_methods_classax_1_1_node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts helper function.  <br /></td></tr>
<tr class="separator:acce3d41422fb5e7e3ead7a03f6e98cc1 inherit pub_static_methods_classax_1_1_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classax_1_1_object"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classax_1_1_object')"><img src="../../closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="../../d0/d25/classax_1_1_object.html">Object</a></td></tr>
<tr class="memitem:a87199ccfa9acfd9dbbe4a61be4f3f15d inherit pub_attribs_classax_1_1_object"><td class="memItemLeft" align="right" valign="top">
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>_ID</b></td></tr>
<tr class="memdesc:a87199ccfa9acfd9dbbe4a61be4f3f15d inherit pub_attribs_classax_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">object id, ScriptSupport need public _ID <br /></td></tr>
<tr class="separator:a87199ccfa9acfd9dbbe4a61be4f3f15d inherit pub_attribs_classax_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb10edfc88a28e6dc62942b7f532edd0 inherit pub_attribs_classax_1_1_object"><td class="memItemLeft" align="right" valign="top">
int&#160;</td><td class="memItemRight" valign="bottom"><b>_luaID</b></td></tr>
<tr class="memdesc:adb10edfc88a28e6dc62942b7f532edd0 inherit pub_attribs_classax_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lua reference id. <br /></td></tr>
<tr class="separator:adb10edfc88a28e6dc62942b7f532edd0 inherit pub_attribs_classax_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a> is a 2d image ( <a href="http://en.wikipedia.org/wiki/Sprite_(computer_graphics)">http://en.wikipedia.org/wiki/Sprite_(computer_graphics)</a> ). </p>
<p><a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a> can be created with an image, or with a sub-rectangle of an image.</p>
<p>To optimize the <a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a> rendering, please follow the following best practices:</p><ul>
<li>Put all your sprites in the same spritesheet (<a href="http://www.codeandweb.com/what-is-a-sprite-sheet">http://www.codeandweb.com/what-is-a-sprite-sheet</a>).</li>
<li>Use the same blending function for all your sprites.</li>
<li>...and the Renderer will automatically "batch" your sprites (will draw all of them in one OpenGL call).</li>
</ul>
<p><a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a> has 4 types or rendering modes:</p>
<ul>
<li><code>QUAD</code>: Renders the sprite using 2 triangles (1 rectangle): uses small memory, but renders empty pixels (slow)</li>
<li><code>POLYGON</code>: Renders the sprite using many triangles (depending on the setting): Uses more memory, but doesn't render so much empty pixels (faster)</li>
<li><code>SLICE9</code>: Renders the sprite using 18 triangles (9 rectangles). Useful to to scale buttons an other rectangular sprites</li>
<li><code>QUAD_BATCHNODE</code>: Renders the sprite using 2 triangles (1 rectangle) with a static batch, which has some limitations (see below)</li>
</ul>
<p>By default, the sprite uses <code>QUAD</code> mode. But can be changed to <code>POLYGON</code> when calling <code><a class="el" href="../../da/d34/classax_1_1_sprite.html#a4e6d475f3c58155baeb3749538d12dd8" title="set the sprite to use this new PolygonInfo">setPolygonInfo()</a></code>. To use <code>SLICE9</code> call <code>setCenterRect()</code> or <code>serCenterRectNormalized()</code>. To use <code>QUAD_BATCHNODE</code> parent the sprite to a <code><a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html" title="SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL c...">SpriteBatchNode</a></code> object.</p>
<p><code>QUAD_BATCHNODE</code> is deprecated and should be avoid. It has the following limitations:</p>
<ul>
<li>The Alias/Antialias property belongs to <code><a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html" title="SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL c...">SpriteBatchNode</a></code>, so you can't individually set the aliased property.</li>
<li>The Blending function property belongs to <code><a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html" title="SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL c...">SpriteBatchNode</a></code>, so you can't individually set the blending function property.</li>
<li><code><a class="el" href="../../d1/d5f/classax_1_1_parallax_node.html" title="ParallaxNode: A node that simulates a parallax scroller.">ParallaxNode</a></code> is not supported, but can be simulated with a "proxy" sprite.</li>
<li>Sprites can only have other Sprites (or subclasses of <a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a>) as children.</li>
</ul>
<p>The default anchorPoint in <a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a> is (0.5, 0.5). </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aef8781bd993ff13b6e7b1fb792d33e20" name="aef8781bd993ff13b6e7b1fb792d33e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8781bd993ff13b6e7b1fb792d33e20">&#9670;&#160;</a></span>create() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> * create </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an empty sprite without texture. </p>
<p>You can call setTexture method subsequently.</p>
<dl class="section return"><dt>Returns</dt><dd>An autoreleased sprite object. </dd></dl>

</div>
</div>
<a id="af55e6b61026fd644e51e2876ed7706ed" name="af55e6b61026fd644e51e2876ed7706ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55e6b61026fd644e51e2876ed7706ed">&#9670;&#160;</a></span>create() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> * create </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a sprite with an image filename. </p>
<p>After creation, the rect of sprite will be the size of the image, and the offset will be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A path to image file, e.g., "scene1/monster.png". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An autoreleased sprite object. </dd></dl>

</div>
</div>
<a id="a310ea446838da614aa3cee08d4d78a76" name="a310ea446838da614aa3cee08d4d78a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310ea446838da614aa3cee08d4d78a76">&#9670;&#160;</a></span>create() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> * create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d78/classax_1_1_polygon_info.html">PolygonInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a polygon sprite with a polygon info. </p>
<p>After creation, the rect of sprite will be the size of the image, and the offset will be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polygonInfo</td><td>A path to image file, e.g., "scene1/monster.png". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An autoreleased sprite object. </dd></dl>

</div>
</div>
<a id="aa803de05042d0ff33057fbd5679c5864" name="aa803de05042d0ff33057fbd5679c5864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa803de05042d0ff33057fbd5679c5864">&#9670;&#160;</a></span>create() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> * create </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a sprite with an image filename and a rect. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A path to image file, e.g., "scene1/monster.png". </td></tr>
    <tr><td class="paramname">rect</td><td>A subrect of the image file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An autoreleased sprite object. </dd></dl>

</div>
</div>
<a id="af36336b69be450688dcf632c9c18ae4a" name="af36336b69be450688dcf632c9c18ae4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af36336b69be450688dcf632c9c18ae4a">&#9670;&#160;</a></span>create() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> * create </td>
          <td>(</td>
          <td class="paramtype">const ax::Data &amp;&#160;</td>
          <td class="paramname"><em>imageData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a sprite with an image data and an image key. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageData</td><td>A Data of the image fil. </td></tr>
    <tr><td class="paramname">key</td><td>The unique key for the image in the cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An autoreleased sprite object. </dd></dl>

</div>
</div>
<a id="a448e4f88b02d9583d2fac3c5c4d6f015" name="a448e4f88b02d9583d2fac3c5c4d6f015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448e4f88b02d9583d2fac3c5c4d6f015">&#9670;&#160;</a></span>createWithTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> * createWithTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html">Texture2D</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a sprite with a <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> object. </p>
<p>After creation, the rect will be the size of the texture, and the offset will be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>A pointer to a <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An autoreleased sprite object. </dd></dl>

</div>
</div>
<a id="af78a23b92614c5ffb19698a72a8291dd" name="af78a23b92614c5ffb19698a72a8291dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78a23b92614c5ffb19698a72a8291dd">&#9670;&#160;</a></span>createWithTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> * createWithTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html">Texture2D</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rotated</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a sprite with a texture and a rect. </p>
<p>After creation, the offset will be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>A pointer to an existing <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> object. You can use a <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> object for many sprites. </td></tr>
    <tr><td class="paramname">rect</td><td>Only the contents inside the rect of this texture will be applied for this sprite. </td></tr>
    <tr><td class="paramname">rotated</td><td>Whether or not the rect is rotated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An autoreleased sprite object. </dd></dl>

</div>
</div>
<a id="a5b1d3fce134f122d42ea525eb2b546cd" name="a5b1d3fce134f122d42ea525eb2b546cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b1d3fce134f122d42ea525eb2b546cd">&#9670;&#160;</a></span>createWithSpriteFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> * createWithSpriteFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html">SpriteFrame</a> *&#160;</td>
          <td class="paramname"><em>spriteFrame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a sprite with an sprite frame. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spriteFrame</td><td>A sprite frame which involves a texture and a rect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An autoreleased sprite object. </dd></dl>

</div>
</div>
<a id="acaabe681cb1669f98560ec876dfdea6e" name="acaabe681cb1669f98560ec876dfdea6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaabe681cb1669f98560ec876dfdea6e">&#9670;&#160;</a></span>createWithSpriteFrameName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> * createWithSpriteFrameName </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>spriteFrameName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a sprite with an sprite frame name. </p>
<p>A <a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html" title="A SpriteFrame has:">SpriteFrame</a> will be fetched from the <a class="el" href="../../d8/dff/classax_1_1_sprite_frame_cache.html" title="Singleton that handles the loading of the sprite frames.">SpriteFrameCache</a> by spriteFrameName param. If the <a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html" title="A SpriteFrame has:">SpriteFrame</a> doesn't exist it will raise an exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spriteFrameName</td><td>The name of sprite frame. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An autoreleased sprite object. </dd></dl>

</div>
</div>
<a id="a4eeafc1ef5d6974e5250aa433eff7f24" name="a4eeafc1ef5d6974e5250aa433eff7f24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eeafc1ef5d6974e5250aa433eff7f24">&#9670;&#160;</a></span>getBatchNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html">SpriteBatchNode</a> * getBatchNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the batch node object if this sprite is rendered by <a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html" title="SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL c...">SpriteBatchNode</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html" title="SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL c...">SpriteBatchNode</a> object if this sprite is rendered by <a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html" title="SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL c...">SpriteBatchNode</a>, nullptr if the sprite isn't used batch node. </dd></dl>

</div>
</div>
<a id="a091145ef619babb53505061d34393d2b" name="a091145ef619babb53505061d34393d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091145ef619babb53505061d34393d2b">&#9670;&#160;</a></span>setBatchNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setBatchNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html">SpriteBatchNode</a> *&#160;</td>
          <td class="paramname"><em>spriteBatchNode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the batch node to sprite. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method is not recommended for game developers. Sample code for using batch node <div class="fragment"><div class="line"><a class="code hl_class" href="../../d2/dc1/classax_1_1_sprite_batch_node.html">SpriteBatchNode</a> *batch = <a class="code hl_function" href="../../df/da2/classax_1_1_node.html#ac7a724506cb799fdcb5971717c72db94">SpriteBatchNode::create</a>(<span class="stringliteral">&quot;Images/grossini_dance_atlas.png&quot;</span>, 15);</div>
<div class="line"><a class="code hl_class" href="../../da/d34/classax_1_1_sprite.html">Sprite</a> *sprite = <a class="code hl_function" href="../../da/d34/classax_1_1_sprite.html#a448e4f88b02d9583d2fac3c5c4d6f015">Sprite::createWithTexture</a>(batch-&gt;getTexture(), <a class="code hl_class" href="../../df/dc5/classax_1_1_rect.html">Rect</a>(0, 0, 57, 57));</div>
<div class="line">batch-&gt;<a class="code hl_function" href="../../d2/dc1/classax_1_1_sprite_batch_node.html#a9bc3fb695690f6b9a722415004eefb24">addChild</a>(sprite);</div>
<div class="line">layer-&gt;addChild(batch);</div>
<div class="ttc" id="aclassax_1_1_node_html_ac7a724506cb799fdcb5971717c72db94"><div class="ttname"><a href="../../df/da2/classax_1_1_node.html#ac7a724506cb799fdcb5971717c72db94">ax::Node::create</a></div><div class="ttdeci">static Node * create()</div><div class="ttdoc">Allocates and initializes a node.</div></div>
<div class="ttc" id="aclassax_1_1_rect_html"><div class="ttname"><a href="../../df/dc5/classax_1_1_rect.html">ax::Rect</a></div><div class="ttdoc">Rectangle area.</div><div class="ttdef"><b>Definition</b> Rect.h:42</div></div>
<div class="ttc" id="aclassax_1_1_sprite_batch_node_html"><div class="ttname"><a href="../../d2/dc1/classax_1_1_sprite_batch_node.html">ax::SpriteBatchNode</a></div><div class="ttdoc">SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL c...</div><div class="ttdef"><b>Definition</b> SpriteBatchNode.h:67</div></div>
<div class="ttc" id="aclassax_1_1_sprite_batch_node_html_a9bc3fb695690f6b9a722415004eefb24"><div class="ttname"><a href="../../d2/dc1/classax_1_1_sprite_batch_node.html#a9bc3fb695690f6b9a722415004eefb24">ax::SpriteBatchNode::addChild</a></div><div class="ttdeci">virtual void addChild(Node *child, int zOrder, int tag) override</div><div class="ttdoc">Adds a child to the container with z order and tag.</div></div>
<div class="ttc" id="aclassax_1_1_sprite_html"><div class="ttname"><a href="../../da/d34/classax_1_1_sprite.html">ax::Sprite</a></div><div class="ttdoc">Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).</div><div class="ttdef"><b>Definition</b> Sprite.h:101</div></div>
<div class="ttc" id="aclassax_1_1_sprite_html_a448e4f88b02d9583d2fac3c5c4d6f015"><div class="ttname"><a href="../../da/d34/classax_1_1_sprite.html#a448e4f88b02d9583d2fac3c5c4d6f015">ax::Sprite::createWithTexture</a></div><div class="ttdeci">static Sprite * createWithTexture(Texture2D *texture)</div><div class="ttdoc">Creates a sprite with a Texture2D object.</div></div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="aed377e7e78da4553c84ec3d96793077b" name="aed377e7e78da4553c84ec3d96793077b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed377e7e78da4553c84ec3d96793077b">&#9670;&#160;</a></span>setTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setTexture </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a new texture (from a filename) to the sprite. </p>
<p>It will call <code><a class="el" href="../../da/d34/classax_1_1_sprite.html#ad527178ae1d61e6898dfca6f3eb76dde" title="Updates the texture rect of the Sprite in points.">setTextureRect()</a></code> with the texture's content size. </p>

</div>
</div>
<a id="ad527178ae1d61e6898dfca6f3eb76dde" name="ad527178ae1d61e6898dfca6f3eb76dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad527178ae1d61e6898dfca6f3eb76dde">&#9670;&#160;</a></span>setTextureRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setTextureRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates the texture rect of the <a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a> in points. </p>
<p>It will call <a class="el" href="../../da/d34/classax_1_1_sprite.html#a71150a4387c1350adc2de58b42670b27" title="This is an overloaded member function, provided for convenience. It differs from the above function o...">setTextureRect(const Rect&amp; rect, bool rotated, const Vec2&amp; untrimmedSize)</a> with <code>rotated</code> = false, and <code>utrimmedSize</code> = rect.size. </p>

</div>
</div>
<a id="a4b614df84073daab9f8c6bf103e33585" name="a4b614df84073daab9f8c6bf103e33585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b614df84073daab9f8c6bf103e33585">&#9670;&#160;</a></span>setVertexRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setVertexRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the vertex rect. </p>
<p>It will be called internally by setTextureRect. Useful if you want to create 2x images from SD images in Retina Display. Do not call it manually. Use setTextureRect instead. </p>

</div>
</div>
<a id="a7733443f098f372d222b9414f130e35e" name="a7733443f098f372d222b9414f130e35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7733443f098f372d222b9414f130e35e">&#9670;&#160;</a></span>setCenterRectNormalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setCenterRectNormalized </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>setCenterRectNormalized </p>
<p>Useful to implement "9 sliced" sprites. The default value is (0,0) - (1,1), which means that only one "slice" will be used: From top-left (0,0) to bottom-right (1,1). If the value is different than (0,0), (1,1), then the sprite will be sliced into a 3 x 3 grid. The four corners of this grid are applied without performing any scaling. The upper- and lower-middle parts are scaled horizontally, and the left- and right-middle parts are scaled vertically. The center is scaled in both directions. Important: The scaling is based the <a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a>'s trimmed size.</p>
<p>Limitations: Does not work when the sprite is part of <code><a class="el" href="../../d2/dc1/classax_1_1_sprite_batch_node.html" title="SpriteBatchNode is like a batch node: if it contains children, it will draw them in 1 single OpenGL c...">SpriteBatchNode</a></code>. </p>

</div>
</div>
<a id="a7d8e6939810e53e95bd124dfcf228ef8" name="a7d8e6939810e53e95bd124dfcf228ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8e6939810e53e95bd124dfcf228ef8">&#9670;&#160;</a></span>getCenterRectNormalized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> getCenterRectNormalized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>getCenterRectNormalized </p>
<p>Returns the CenterRect in normalized coordinates </p>

</div>
</div>
<a id="a8925da3cd8a509e4e5f83a0fa1358dae" name="a8925da3cd8a509e4e5f83a0fa1358dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8925da3cd8a509e4e5f83a0fa1358dae">&#9670;&#160;</a></span>getCenterRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> getCenterRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Cap Insets rect. </p>
<dl class="section return"><dt>Returns</dt><dd>Scale9Sprite's cap inset. </dd></dl>

</div>
</div>
<a id="aa84b905afd2729bf7723055c23cb1405" name="aa84b905afd2729bf7723055c23cb1405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84b905afd2729bf7723055c23cb1405">&#9670;&#160;</a></span>setSpriteFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setSpriteFrame </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>spriteFrameName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a new <a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html" title="A SpriteFrame has:">SpriteFrame</a> to the <a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a>. </p>

<p>Reimplemented in <a class="el" href="../../db/ddc/classax_1_1ui_1_1_scale9_sprite.html#aa84b905afd2729bf7723055c23cb1405">Scale9Sprite</a>.</p>

</div>
</div>
<a id="aa5f5665fee653d2ad306257772f78ff2" name="aa5f5665fee653d2ad306257772f78ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f5665fee653d2ad306257772f78ff2">&#9670;&#160;</a></span>setDisplayFrameWithAnimationName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setDisplayFrameWithAnimationName </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>animationName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>frameIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the display frame with animation name and index. </p>
<p>The animation name will be get from the <a class="el" href="../../d7/d91/classax_1_1_animation_cache.html" title="Singleton that manages the Animations.">AnimationCache</a>. </p>

</div>
</div>
<a id="af1e28704e545c423a0551118fc31b7d6" name="af1e28704e545c423a0551118fc31b7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e28704e545c423a0551118fc31b7d6">&#9670;&#160;</a></span>isDirty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool isDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether or not the <a class="el" href="../../da/d34/classax_1_1_sprite.html" title="Sprite is a 2d image ( http://en.wikipedia.org/wiki/Sprite_(computer_graphics) ).">Sprite</a> needs to be updated in the Atlas. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the sprite needs to be updated in the Atlas, false otherwise. </dd></dl>

</div>
</div>
<a id="abbf536d9e9fdbdb51ed9337fe9ddccd1" name="abbf536d9e9fdbdb51ed9337fe9ddccd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf536d9e9fdbdb51ed9337fe9ddccd1">&#9670;&#160;</a></span>setScaleX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setScaleX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the scale (x) of the node. </p>
<p>It is a scaling factor that multiplies the width of the node and its children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleX</td><td>The scale factor on X axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#aed0ec67a2bb5ae4d2049abf37c76be81">Node</a>.</p>

</div>
</div>
<a id="a0ff1c296d7635bcbf74e6afbd75bf2c8" name="a0ff1c296d7635bcbf74e6afbd75bf2c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff1c296d7635bcbf74e6afbd75bf2c8">&#9670;&#160;</a></span>setScaleY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setScaleY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the scale (y) of the node. </p>
<p>It is a scaling factor that multiplies the height of the node and its children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleY</td><td>The scale factor on Y axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a4db8536a9f45dd467512e55bb18403ad">Node</a>.</p>

</div>
</div>
<a id="a10a101451c2fcd3e847ad10e8c04d757" name="a10a101451c2fcd3e847ad10e8c04d757"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a101451c2fcd3e847ad10e8c04d757">&#9670;&#160;</a></span>setScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scaleY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the scale (x,y) of the node. </p>
<p>It is a scaling factor that multiplies the width and height of the node and its children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleX</td><td>The scale factor on X axis. </td></tr>
    <tr><td class="paramname">scaleY</td><td>The scale factor on Y axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#ad890743ea7159925d7a677da89bd94b6">Node</a>.</p>

</div>
</div>
<a id="a915b097d1f266fd315ab2151e5af887d" name="a915b097d1f266fd315ab2151e5af887d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915b097d1f266fd315ab2151e5af887d">&#9670;&#160;</a></span>setPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setPosition </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the position (x,y) of the node in its parent's coordinate system. </p>
<p>Passing two numbers (x,y) is much efficient than passing <a class="el" href="../../d3/d6f/classax_1_1_vec2.html" title="Defines a 2-element floating point vector.">Vec2</a> object. This method is bound to Lua and JavaScript. Passing a number is 10 times faster than passing a object from Lua to c++.</p>
<div class="fragment"><div class="line"><span class="comment">// sample code in Lua</span></div>
<div class="line">local pos  = node::getPosition()  -- returns <a class="code hl_class" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> <span class="keywordtype">object</span> from C++.</div>
<div class="line">node:<a class="code hl_function" href="../../da/d34/classax_1_1_sprite.html#ac1be6ca229d92a1a145fda8a7eece771">setPosition</a>(x, y)            -- pass x, y coordinate to C++.</div>
<div class="ttc" id="aclassax_1_1_sprite_html_ac1be6ca229d92a1a145fda8a7eece771"><div class="ttname"><a href="../../da/d34/classax_1_1_sprite.html#ac1be6ca229d92a1a145fda8a7eece771">ax::Sprite::setPosition</a></div><div class="ttdeci">virtual void setPosition(const Vec2 &amp;pos) override</div><div class="ttdoc">@js NA @lua NA</div></div>
<div class="ttc" id="aclassax_1_1_vec2_html"><div class="ttname"><a href="../../d3/d6f/classax_1_1_vec2.html">ax::Vec2</a></div><div class="ttdoc">Defines a 2-element floating point vector.</div><div class="ttdef"><b>Definition</b> Vec2.h:59</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>X coordinate for position. </td></tr>
    <tr><td class="paramname">y</td><td>Y coordinate for position. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a331195336739d9167f1e8ffd611bb325">Node</a>.</p>

</div>
</div>
<a id="a9d8fc948a289f8628745bc4c7f382996" name="a9d8fc948a289f8628745bc4c7f382996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8fc948a289f8628745bc4c7f382996">&#9670;&#160;</a></span>setRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setRotation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the rotation (angle) of the node in degrees. </p>
<p>0 is the default rotation angle. Positive values rotate node clockwise, and negative values for anti-clockwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotation</td><td>The rotation of the node in degrees. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#adababeeaed26db2306df84e337b4ea37">Node</a>.</p>

</div>
</div>
<a id="a960d510ca897a764062a0bf22fa3dbc3" name="a960d510ca897a764062a0bf22fa3dbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960d510ca897a764062a0bf22fa3dbc3">&#9670;&#160;</a></span>setRotationSkewX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setRotationSkewX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotationX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the X rotation (angle) of the node in degrees which performs a horizontal rotational skew. </p>
<p>The difference between <code>setRotationalSkew()</code> and <code>setSkew()</code> is that the first one simulate Flash's skew functionality, while the second one uses the real skew function.</p>
<p>0 is the default rotation angle. Positive values rotate node clockwise, and negative values for anti-clockwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotationX</td><td>The X rotation in degrees which performs a horizontal rotational skew.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. @js setRotationX </dd></dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a274823dc85882e933932f4a24c24eec8">Node</a>.</p>

</div>
</div>
<a id="afa805b84f34c11e8b9d4e9c1d6cba1c7" name="afa805b84f34c11e8b9d4e9c1d6cba1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa805b84f34c11e8b9d4e9c1d6cba1c7">&#9670;&#160;</a></span>setRotationSkewY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setRotationSkewY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotationY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the Y rotation (angle) of the node in degrees which performs a vertical rotational skew. </p>
<p>The difference between <code>setRotationalSkew()</code> and <code>setSkew()</code> is that the first one simulate Flash's skew functionality, while the second one uses the real skew function.</p>
<p>0 is the default rotation angle. Positive values rotate node clockwise, and negative values for anti-clockwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rotationY</td><td>The Y rotation in degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. @js setRotationY </dd></dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a4a5ee7b3580ff634d02e172be8351e4c">Node</a>.</p>

</div>
</div>
<a id="a0ddb221e19282c51743bf18c5be81b73" name="a0ddb221e19282c51743bf18c5be81b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddb221e19282c51743bf18c5be81b73">&#9670;&#160;</a></span>setSkewX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setSkewX </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>skewX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the X skew angle of the node in degrees. </p>
<p>The difference between <code>setRotationalSkew()</code> and <code>setSkew()</code> is that the first one simulate Flash's skew functionality while the second one uses the real skew function.</p>
<p>This angle describes the shear distortion in the X direction. Thus, it is the angle between the Y coordinate and the left edge of the shape The default skewX angle is 0. Positive values distort the node in a CW direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skewX</td><td>The X skew angle of the node in degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a1086d6be1498e0db8a4cacbd3ebded48">Node</a>.</p>

</div>
</div>
<a id="acdb24aba0a9f48408005c6fa2185ea6a" name="acdb24aba0a9f48408005c6fa2185ea6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb24aba0a9f48408005c6fa2185ea6a">&#9670;&#160;</a></span>setSkewY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setSkewY </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>skewY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the Y skew angle of the node in degrees. </p>
<p>The difference between <code>setRotationalSkew()</code> and <code>setSkew()</code> is that the first one simulate Flash's skew functionality while the second one uses the real skew function.</p>
<p>This angle describes the shear distortion in the Y direction. Thus, it is the angle between the X coordinate and the bottom edge of the shape. The default skewY angle is 0. Positive values distort the node in a CCW direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">skewY</td><td>The Y skew angle of the node in degrees.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#ae8b0dd476af42d56ecf7994283286664">Node</a>.</p>

</div>
</div>
<a id="a7b91371184c82988923c933c0a52bd98" name="a7b91371184c82988923c933c0a52bd98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b91371184c82988923c933c0a52bd98">&#9670;&#160;</a></span>removeChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void removeChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanup</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes a child from the container. </p>
<p>It will also cleanup all running actions depending on the cleanup parameter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child node which will be removed. </td></tr>
    <tr><td class="paramname">cleanup</td><td>True if all running actions and callbacks on the child node will be cleanup, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#ad4548a27e089986fad71fdc09220fd32">Node</a>.</p>

</div>
</div>
<a id="aadf73dfdd41e1754ef0e2c65dff30755" name="aadf73dfdd41e1754ef0e2c65dff30755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadf73dfdd41e1754ef0e2c65dff30755">&#9670;&#160;</a></span>removeAllChildrenWithCleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void removeAllChildrenWithCleanup </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cleanup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all children from the container, and do a cleanup to all running actions depending on the cleanup parameter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cleanup</td><td>True if all running actions on all children nodes should be cleanup, false otherwise. @js removeAllChildren @lua removeAllChildren </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a0b5b225479b416b6d9f701c5de7e7e63">Node</a>.</p>

</div>
</div>
<a id="a1461c8513c94a6c205448da6d23fef28" name="a1461c8513c94a6c205448da6d23fef28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1461c8513c94a6c205448da6d23fef28">&#9670;&#160;</a></span>reorderChild()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void reorderChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reorders a child according to a new z value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>An already added child node. It MUST be already added. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <a class="el" href="../../df/da2/classax_1_1_node.html#a30da2e2f84bf5dab27e7bf850ad80ec1" title="LocalZOrder is the &#39;key&#39; used to sort the node relative to its siblings.">setLocalZOrder(int)</a>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#aa0dac0681a42c82d993a06c364cfc615">Node</a>.</p>

</div>
</div>
<a id="a9bc3fb695690f6b9a722415004eefb24" name="a9bc3fb695690f6b9a722415004eefb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc3fb695690f6b9a722415004eefb24">&#9670;&#160;</a></span>addChild() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a child to the container with z order and tag. </p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <code><a class="el" href="../../df/da2/classax_1_1_node.html#a30da2e2f84bf5dab27e7bf850ad80ec1" title="LocalZOrder is the &#39;key&#39; used to sort the node relative to its siblings.">setLocalZOrder(int)</a></code>. </td></tr>
    <tr><td class="paramname">tag</td><td>An integer to identify the node easily. Please refer to <code><a class="el" href="../../df/da2/classax_1_1_node.html#af833eb63c35974aff52d336565fd89cd" title="Changes the tag that is used to identify the node easily.">setTag(int)</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Please use <code>addChild(Node* child, int localZOrder, const std::string &amp;name)</code> instead. </p>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a81750b6b1e67c0e99c71bae5ce5779bc">Node</a>.</p>

</div>
</div>
<a id="ab3fef288b1bdfbc5c81d17189ef5bf1a" name="ab3fef288b1bdfbc5c81d17189ef5bf1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3fef288b1bdfbc5c81d17189ef5bf1a">&#9670;&#160;</a></span>addChild() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a child to the container with z order and tag. </p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <code><a class="el" href="../../df/da2/classax_1_1_node.html#a30da2e2f84bf5dab27e7bf850ad80ec1" title="LocalZOrder is the &#39;key&#39; used to sort the node relative to its siblings.">setLocalZOrder(int)</a></code>. </td></tr>
    <tr><td class="paramname">name</td><td>A string to identify the node easily. Please refer to <code>setName(int)</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#abd4f157c6f3d4e9f3da98d05b53e061b">Node</a>.</p>

</div>
</div>
<a id="aff5dacbfb9541bde2108ad94edbbe6cc" name="aff5dacbfb9541bde2108ad94edbbe6cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5dacbfb9541bde2108ad94edbbe6cc">&#9670;&#160;</a></span>sortAllChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void sortAllChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the children array once before drawing, instead of every time when a child is added or reordered. </p>
<p>This approach can improve the performance massively. </p><dl class="section note"><dt>Note</dt><dd>Don't call this manually unless a child added needs to be removed in the same frame. </dd></dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a123d030d1b3aa3293d13252aa3bddf85">Node</a>.</p>

</div>
</div>
<a id="aba8cb6b2364f18f8b8cb2abc9fe6828f" name="aba8cb6b2364f18f8b8cb2abc9fe6828f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8cb6b2364f18f8b8cb2abc9fe6828f">&#9670;&#160;</a></span>setScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the scale (x,y,z) of the node. </p>
<p>It is a scaling factor that multiplies the width, height and depth of the node and its children.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The scale factor for both X and Y axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The physics body doesn't support this. </dd></dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#ac91c54136908f520b748be4a69ace0c0">Node</a>.</p>

</div>
</div>
<a id="a815dbbcdb2a48189e685166f3e71926c" name="a815dbbcdb2a48189e685166f3e71926c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815dbbcdb2a48189e685166f3e71926c">&#9670;&#160;</a></span>setPositionZ()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setPositionZ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>positionZ</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the 'z' coordinate in the position. </p>
<p>It is the OpenGL Z vertex value.</p>
<p>The OpenGL depth buffer and depth testing are disabled by default. You need to turn them on. In order to use this property correctly.</p>
<p><code><a class="el" href="../../da/d34/classax_1_1_sprite.html#a815dbbcdb2a48189e685166f3e71926c" title="Sets the &#39;z&#39; coordinate in the position.">setPositionZ()</a></code> also sets the <code>setGlobalZValue()</code> with the positionZ as value.</p>
<dl class="section see"><dt>See also</dt><dd><code>setGlobalZValue()</code></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positionZ</td><td>OpenGL Z vertex of this node. @js setVertexZ </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a36332c25df9b0c9f0197a645658d1581">Node</a>.</p>

</div>
</div>
<a id="a27e6d20338e65d260f589c188305df66" name="a27e6d20338e65d260f589c188305df66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e6d20338e65d260f589c188305df66">&#9670;&#160;</a></span>setAnchorPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setAnchorPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>anchorPoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the anchor point in percent. </p>
<p>anchorPoint is the point around which all transformations and positioning manipulations take place. It's like a pin in the node where it is "attached" to its parent. The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner. But you can use values higher than (1,1) and lower than (0,0) too. The default anchorPoint is (0,0), so it starts in the lower left corner of the node. </p><dl class="section note"><dt>Note</dt><dd>If node has a physics body, the anchor must be in the middle, you can't change this to other value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anchorPoint</td><td>The anchor point of node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#abf77210f31f01d0f564600c94c90e2be">Node</a>.</p>

<p>Reimplemented in <a class="el" href="../../d3/db5/classax_1_1_anchored_sprite.html#a27e6d20338e65d260f589c188305df66">AnchoredSprite</a>.</p>

</div>
</div>
<a id="a4a10bd40ac7cd657d96075196cadc681" name="a4a10bd40ac7cd657d96075196cadc681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a10bd40ac7cd657d96075196cadc681">&#9670;&#160;</a></span>setContentSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setContentSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>contentSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the untransformed size of the node. </p>
<p>The contentSize remains the same no matter the node is scaled or rotated. All nodes has a size. Layer and <a class="el" href="../../de/db8/classax_1_1_scene.html" title="Scene is a subclass of Node that is used only as an abstract concept.">Scene</a> has the same size of the screen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">contentSize</td><td>The untransformed size of the node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a442d24bed031dc53d7bac7dea36c7c53">Node</a>.</p>

</div>
</div>
<a id="aa3e159ab16183d5412ba16b0c25fbc1b" name="aa3e159ab16183d5412ba16b0c25fbc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3e159ab16183d5412ba16b0c25fbc1b">&#9670;&#160;</a></span>setIgnoreAnchorPointForPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setIgnoreAnchorPointForPosition </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the anchor point will be (0,0) when you position this node. </p>
<p>This is an internal method, only used by Layer and <a class="el" href="../../de/db8/classax_1_1_scene.html" title="Scene is a subclass of Node that is used only as an abstract concept.">Scene</a>. Don't call it outside framework. The default value is false, while in Layer and <a class="el" href="../../de/db8/classax_1_1_scene.html" title="Scene is a subclass of Node that is used only as an abstract concept.">Scene</a> are true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ignore</td><td>true if anchor point will be (0,0) when you position this node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a5362a3d059b50f6165f5edbeaa83199f">Node</a>.</p>

</div>
</div>
<a id="a6df7f98422c04133e00f03324078ac78" name="a6df7f98422c04133e00f03324078ac78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df7f98422c04133e00f03324078ac78">&#9670;&#160;</a></span>setVisible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setVisible </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visible</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets whether the node is visible. </p>
<p>The default value is true, a node is default to visible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">visible</td><td>true if the node is visible, false if the node is hidden. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#aff6547edc5bdc358ad27566775035b3c">Node</a>.</p>

</div>
</div>
<a id="a0f59730fa0bd109f318e0a18bb4f8945" name="a0f59730fa0bd109f318e0a18bb4f8945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f59730fa0bd109f318e0a18bb4f8945">&#9670;&#160;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void draw </td>
          <td>(</td>
          <td class="paramtype">Renderer *&#160;</td>
          <td class="paramname"><em>renderer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/d6e/classax_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override this method to draw your own node. </p>
<p>The following GL states will be enabled by default:</p><ul>
<li><code>glEnableClientState(GL_VERTEX_ARRAY);</code></li>
<li><code>glEnableClientState(GL_COLOR_ARRAY);</code></li>
<li><code>glEnableClientState(GL_TEXTURE_COORD_ARRAY);</code></li>
<li><code>glEnable(GL_TEXTURE_2D);</code> AND YOU SHOULD NOT DISABLE THEM AFTER DRAWING YOUR NODE But if you enable any other GL state, you should disable it after drawing your node.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>A given renderer. </td></tr>
    <tr><td class="paramname">transform</td><td>A transform matrix. </td></tr>
    <tr><td class="paramname">flags</td><td>Renderer flag. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#afbf06584207d830ad5604f077667bbf4">Node</a>.</p>

<p>Reimplemented in <a class="el" href="../../dd/d37/classax_1_1_bill_board.html#a0f59730fa0bd109f318e0a18bb4f8945">BillBoard</a>.</p>

</div>
</div>
<a id="a1e8279c03b7acf14855fa31c1ad08abb" name="a1e8279c03b7acf14855fa31c1ad08abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8279c03b7acf14855fa31c1ad08abb">&#9670;&#160;</a></span>setOpacityModifyRGB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setOpacityModifyRGB </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If you want the opacity affect the color property, then set to true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A boolean value. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a6463289cc9eeb21a62835f961be61b12">Node</a>.</p>

</div>
</div>
<a id="a1a218c437a2b29c7aef17438229c292a" name="a1a218c437a2b29c7aef17438229c292a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a218c437a2b29c7aef17438229c292a">&#9670;&#160;</a></span>isOpacityModifyRGB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool isOpacityModifyRGB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If node opacity will modify the RGB color value, then you should override this method and return true. </p>
<dl class="section return"><dt>Returns</dt><dd>A boolean value, true indicates that opacity will modify color; false otherwise. </dd></dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a9991c954066be613624f4692d6146988">Node</a>.</p>

</div>
</div>
<a id="a8c512ddf90467ffe2f39a036f8425705" name="a8c512ddf90467ffe2f39a036f8425705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c512ddf90467ffe2f39a036f8425705">&#9670;&#160;</a></span>getQuad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d8/dcb/structax_1_1_v3_f___c4_b___t2_f___quad.html">V3F_C4B_T2F_Quad</a> &amp; getQuad </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the quad (tex coords, vertex coords and color) information. </p>
<p>@js NA @lua NA </p>

</div>
</div>
<a id="a71ba1bde12abab899dd477694b2d0440" name="a71ba1bde12abab899dd477694b2d0440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71ba1bde12abab899dd477694b2d0440">&#9670;&#160;</a></span>setAtlasIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setAtlasIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>atlasIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the index used on the <a class="el" href="../../de/dd0/classax_1_1_texture_atlas.html" title="A class that implements a Texture Atlas.">TextureAtlas</a>. </p>
<dl class="section warning"><dt>Warning</dt><dd>Don't modify this value unless you know what you are doing. </dd></dl>

</div>
</div>
<a id="ad234d0952086e40d256b33d363554bb3" name="ad234d0952086e40d256b33d363554bb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad234d0952086e40d256b33d363554bb3">&#9670;&#160;</a></span>getOffsetPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d3/d6f/classax_1_1_vec2.html">Vec2</a> &amp; getOffsetPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the offset position of the sprite. </p>
<p>Calculated automatically by editors like Zwoptex. </p>

</div>
</div>
<a id="a7baa2b07a6417416039b0de8f845156c" name="a7baa2b07a6417416039b0de8f845156c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7baa2b07a6417416039b0de8f845156c">&#9670;&#160;</a></span>isFlippedX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isFlippedX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the flag which indicates whether the sprite is flipped horizontally or not. </p>
<p>It only flips the texture of the sprite, and not the texture of the sprite's children. Also, flipping the texture doesn't alter the anchorPoint. If you want to flip the anchorPoint too, and/or to flip the children too use: sprite-&gt;setScaleX(sprite-&gt;<a class="el" href="../../df/da2/classax_1_1_node.html#ab7295c2bdcac8b28b2f333b83eb1e678" title="Returns the scale factor on X axis of this node.">getScaleX()</a> * -1);</p>
<dl class="section return"><dt>Returns</dt><dd>true if the sprite is flipped horizontally, false otherwise. </dd></dl>

</div>
</div>
<a id="ae5c337848ad0070a3bdf3e32393a9214" name="ae5c337848ad0070a3bdf3e32393a9214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c337848ad0070a3bdf3e32393a9214">&#9670;&#160;</a></span>setFlippedX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setFlippedX </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flippedX</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the sprite should be flipped horizontally or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flippedX</td><td>true if the sprite should be flipped horizontally, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7600f94a70e244d43fcb0d6b70423ec" name="af7600f94a70e244d43fcb0d6b70423ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7600f94a70e244d43fcb0d6b70423ec">&#9670;&#160;</a></span>isFlippedY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isFlippedY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the flag which indicates whether the sprite is flipped vertically or not. </p>
<p>It only flips the texture of the sprite, and not the texture of the sprite's children. Also, flipping the texture doesn't alter the anchorPoint. If you want to flip the anchorPoint too, and/or to flip the children too use: sprite-&gt;setScaleY(sprite-&gt;<a class="el" href="../../df/da2/classax_1_1_node.html#a00e6602898f2d25d02abc1da4ff400a5" title="Returns the scale factor on Y axis of this node.">getScaleY()</a> * -1);</p>
<dl class="section return"><dt>Returns</dt><dd>true if the sprite is flipped vertically, false otherwise. </dd></dl>

</div>
</div>
<a id="ab147ec91d225a67202ac401061134f80" name="ab147ec91d225a67202ac401061134f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab147ec91d225a67202ac401061134f80">&#9670;&#160;</a></span>setFlippedY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setFlippedY </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>flippedY</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets whether the sprite should be flipped vertically or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flippedY</td><td>true if the sprite should be flipped vertically, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdaaa9a13f44453effcd71d6708da41c" name="afdaaa9a13f44453effcd71d6708da41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdaaa9a13f44453effcd71d6708da41c">&#9670;&#160;</a></span>getPolygonInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="../../d6/d78/classax_1_1_polygon_info.html">PolygonInfo</a> &amp; getPolygonInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a reference of the polygon information associated with this sprite </p>
<dl class="section return"><dt>Returns</dt><dd>a reference of <a class="el" href="../../d6/d78/classax_1_1_polygon_info.html" title="PolygonInfo is an object holding the required data to display Sprites.">PolygonInfo</a> </dd></dl>

</div>
</div>
<a id="a4e6d475f3c58155baeb3749538d12dd8" name="a4e6d475f3c58155baeb3749538d12dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6d475f3c58155baeb3749538d12dd8">&#9670;&#160;</a></span>setPolygonInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setPolygonInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d78/classax_1_1_polygon_info.html">PolygonInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>set the sprite to use this new <a class="el" href="../../d6/d78/classax_1_1_polygon_info.html" title="PolygonInfo is an object holding the required data to display Sprites.">PolygonInfo</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="../../d6/d78/classax_1_1_polygon_info.html" title="PolygonInfo is an object holding the required data to display Sprites.">PolygonInfo</a></td><td>the polygon information object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8260900844faf4e9e4261f1477b07b1a" name="a8260900844faf4e9e4261f1477b07b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8260900844faf4e9e4261f1477b07b1a">&#9670;&#160;</a></span>setBlendFunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setBlendFunc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/df9/structax_1_1_blend_func.html">BlendFunc</a> &amp;&#160;</td>
          <td class="paramname"><em>blendFunc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<div class="fragment"><div class="line">*When <span class="keyword">this</span> function bound into js or lua,the parameter will be changed.</div>
<div class="line">*In js: var <a class="code hl_function" href="../../da/d34/classax_1_1_sprite.html#a8260900844faf4e9e4261f1477b07b1a">setBlendFunc</a>(var src, var dst).</div>
<div class="line">*In lua: local <a class="code hl_function" href="../../da/d34/classax_1_1_sprite.html#a8260900844faf4e9e4261f1477b07b1a">setBlendFunc</a>(local src, local dst).</div>
<div class="ttc" id="aclassax_1_1_sprite_html_a8260900844faf4e9e4261f1477b07b1a"><div class="ttname"><a href="../../da/d34/classax_1_1_sprite.html#a8260900844faf4e9e4261f1477b07b1a">ax::Sprite::setBlendFunc</a></div><div class="ttdeci">void setBlendFunc(const BlendFunc &amp;blendFunc) override</div><div class="ttdef"><b>Definition</b> Sprite.h:518</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab7ad1fdbf19a0bf60f21e8e565c37d4d" name="ab7ad1fdbf19a0bf60f21e8e565c37d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ad1fdbf19a0bf60f21e8e565c37d4d">&#9670;&#160;</a></span>initWithTexture() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool initWithTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html">Texture2D</a> *&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a sprite with a texture. </p>
<p>After initialization, the rect used will be the size of the texture, and the offset will be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>A pointer to an existing <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> object. You can use a <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> object for many sprites. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sprite is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a id="adcb52d750835b981593a13f12b99c854" name="adcb52d750835b981593a13f12b99c854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcb52d750835b981593a13f12b99c854">&#9670;&#160;</a></span>initWithPolygon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool initWithPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d6/d78/classax_1_1_polygon_info.html">PolygonInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a sprite with a <a class="el" href="../../d6/d78/classax_1_1_polygon_info.html" title="PolygonInfo is an object holding the required data to display Sprites.">PolygonInfo</a>. </p>
<p>After initialization, the rect used will be the size of the texture, and the offset will be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="../../d6/d78/classax_1_1_polygon_info.html" title="PolygonInfo is an object holding the required data to display Sprites.">PolygonInfo</a></td><td>a Polygon info contains the structure of the polygon. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sprite is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a id="a7d1c74e5a8560fa562cc35bbbb994044" name="a7d1c74e5a8560fa562cc35bbbb994044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d1c74e5a8560fa562cc35bbbb994044">&#9670;&#160;</a></span>initWithTexture() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool initWithTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html">Texture2D</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a sprite with a texture and a rect. </p>
<p>After initialization, the offset will be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>A pointer to an existing <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> object. You can use a <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> object for many sprites. </td></tr>
    <tr><td class="paramname">rect</td><td>Only the contents inside rect of this texture will be applied for this sprite. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sprite is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a id="ad584036b6c0112e5af1f853ff6d350a7" name="ad584036b6c0112e5af1f853ff6d350a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad584036b6c0112e5af1f853ff6d350a7">&#9670;&#160;</a></span>initWithTexture() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool initWithTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html">Texture2D</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rotated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a sprite with a texture and a rect in points, optionally rotated. </p>
<p>After initialization, the offset will be (0,0). </p><dl class="section note"><dt>Note</dt><dd>This is the designated initializer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>A <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> object whose texture will be applied to this sprite. </td></tr>
    <tr><td class="paramname">rect</td><td>A rectangle assigned the contents of texture. </td></tr>
    <tr><td class="paramname">rotated</td><td>Whether or not the texture rectangle is rotated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sprite is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a id="aa7d49741bdfe37368109c434a0f9e3a0" name="aa7d49741bdfe37368109c434a0f9e3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7d49741bdfe37368109c434a0f9e3a0">&#9670;&#160;</a></span>initWithSpriteFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool initWithSpriteFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html">SpriteFrame</a> *&#160;</td>
          <td class="paramname"><em>spriteFrame</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a sprite with an <a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html" title="A SpriteFrame has:">SpriteFrame</a>. </p>
<p>The texture and rect in <a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html" title="A SpriteFrame has:">SpriteFrame</a> will be applied on this sprite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spriteFrame</td><td>A <a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html" title="A SpriteFrame has:">SpriteFrame</a> object. It should includes a valid texture and a rect. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sprite is initialized properly, false otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="../../db/ddc/classax_1_1ui_1_1_scale9_sprite.html#aa7d49741bdfe37368109c434a0f9e3a0">Scale9Sprite</a>.</p>

</div>
</div>
<a id="a42535d3cc64775aaa3e596888ff2740d" name="a42535d3cc64775aaa3e596888ff2740d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42535d3cc64775aaa3e596888ff2740d">&#9670;&#160;</a></span>initWithSpriteFrameName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool initWithSpriteFrameName </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>spriteFrameName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a sprite with an sprite frame name. </p>
<p>A <a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html" title="A SpriteFrame has:">SpriteFrame</a> will be fetched from the <a class="el" href="../../d8/dff/classax_1_1_sprite_frame_cache.html" title="Singleton that handles the loading of the sprite frames.">SpriteFrameCache</a> by name. If the <a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html" title="A SpriteFrame has:">SpriteFrame</a> doesn't exist it will raise an exception.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spriteFrameName</td><td>A key string that can fetched a valid <a class="el" href="../../d4/da6/classax_1_1_sprite_frame.html" title="A SpriteFrame has:">SpriteFrame</a> from <a class="el" href="../../d8/dff/classax_1_1_sprite_frame_cache.html" title="Singleton that handles the loading of the sprite frames.">SpriteFrameCache</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sprite is initialized properly, false otherwise. </dd></dl>

<p>Reimplemented in <a class="el" href="../../db/ddc/classax_1_1ui_1_1_scale9_sprite.html#a42535d3cc64775aaa3e596888ff2740d">Scale9Sprite</a>, and <a class="el" href="../../db/ddc/classax_1_1ui_1_1_scale9_sprite.html#a8115648afe45eaaa03b4d0546fcd860e">Scale9Sprite</a>.</p>

</div>
</div>
<a id="a75e13e3719edd482bd4beab93110878f" name="a75e13e3719edd482bd4beab93110878f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75e13e3719edd482bd4beab93110878f">&#9670;&#160;</a></span>initWithFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool initWithFile </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a sprite with an image filename. </p>
<p>This method will find filename from local file system, load its content to <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a>, then use <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> to create a sprite. After initialization, the rect used will be the size of the image. The offset will be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The path to an image file in local file system. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sprite is initialized properly, false otherwise. @lua init </dd></dl>

<p>Reimplemented in <a class="el" href="../../db/ddc/classax_1_1ui_1_1_scale9_sprite.html#a55e4071a5e46cb19c4cb3b088f064bae">Scale9Sprite</a>, and <a class="el" href="../../db/ddc/classax_1_1ui_1_1_scale9_sprite.html#a75e13e3719edd482bd4beab93110878f">Scale9Sprite</a>.</p>

</div>
</div>
<a id="a3dfc880b51f3b1224e8166bf0fe1bfd3" name="a3dfc880b51f3b1224e8166bf0fe1bfd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dfc880b51f3b1224e8166bf0fe1bfd3">&#9670;&#160;</a></span>initWithFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool initWithFile </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dc5/classax_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a sprite with an image filename, and a rect. </p>
<p>This method will find filename from local file system, load its content to <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a>, then use <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> to create a sprite. After initialization, the offset will be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The path to an image file in local file system. </td></tr>
    <tr><td class="paramname">rect</td><td>The rectangle assigned the content area from texture. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sprite is initialized properly, false otherwise. @lua init </dd></dl>

<p>Reimplemented in <a class="el" href="../../db/ddc/classax_1_1ui_1_1_scale9_sprite.html#a77a3f00a1bd23849e3a69bd6f36e75c6">Scale9Sprite</a>, and <a class="el" href="../../db/ddc/classax_1_1ui_1_1_scale9_sprite.html#a3dfc880b51f3b1224e8166bf0fe1bfd3">Scale9Sprite</a>.</p>

</div>
</div>
<a id="ab9f26a305c777e8053202c00abdda28e" name="ab9f26a305c777e8053202c00abdda28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f26a305c777e8053202c00abdda28e">&#9670;&#160;</a></span>initWithImageData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool initWithImageData </td>
          <td>(</td>
          <td class="paramtype">const ax::Data &amp;&#160;</td>
          <td class="paramname"><em>imageData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes a sprite with an image data, and a key for the cache. </p>
<p>This method will load the image data to <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a>, then use <a class="el" href="../../d3/dd4/classax_1_1_texture2_d.html" title="Texture2D class.">Texture2D</a> to create a sprite. After initialization, the offset will be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageData</td><td>The image data </td></tr>
    <tr><td class="paramname">key</td><td>The key for cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the sprite is initialized properly, false otherwise. @lua init </dd></dl>

</div>
</div>
<a id="a3eaacdcdb32cf2de74fbedaaad63f8e0" name="a3eaacdcdb32cf2de74fbedaaad63f8e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eaacdcdb32cf2de74fbedaaad63f8e0">&#9670;&#160;</a></span>setAutoSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setAutoSize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicate if the sprite content size can change if new textures are applied to the sprite. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>True if the sprite can change size on new frames/textures </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa1f21f77c26adee1ce1444b31c69178" name="aaa1f21f77c26adee1ce1444b31c69178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1f21f77c26adee1ce1444b31c69178">&#9670;&#160;</a></span>addChild() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a child to the container with z-order as 0. </p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#aaa1f21f77c26adee1ce1444b31c69178">Node</a>.</p>

</div>
</div>
<a id="a8f3ae9edda24b62e88cc6e76c4201b7a" name="a8f3ae9edda24b62e88cc6e76c4201b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f3ae9edda24b62e88cc6e76c4201b7a">&#9670;&#160;</a></span>addChild() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a child to the container with a local z-order. </p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <code><a class="el" href="../../df/da2/classax_1_1_node.html#a30da2e2f84bf5dab27e7bf850ad80ec1" title="LocalZOrder is the &#39;key&#39; used to sort the node relative to its siblings.">setLocalZOrder(int)</a></code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a8f3ae9edda24b62e88cc6e76c4201b7a">Node</a>.</p>

</div>
</div>
<a id="a81750b6b1e67c0e99c71bae5ce5779bc" name="a81750b6b1e67c0e99c71bae5ce5779bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81750b6b1e67c0e99c71bae5ce5779bc">&#9670;&#160;</a></span>addChild() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a child to the container with z order and tag. </p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <code><a class="el" href="../../df/da2/classax_1_1_node.html#a30da2e2f84bf5dab27e7bf850ad80ec1" title="LocalZOrder is the &#39;key&#39; used to sort the node relative to its siblings.">setLocalZOrder(int)</a></code>. </td></tr>
    <tr><td class="paramname">tag</td><td>An integer to identify the node easily. Please refer to <code><a class="el" href="../../df/da2/classax_1_1_node.html#af833eb63c35974aff52d336565fd89cd" title="Changes the tag that is used to identify the node easily.">setTag(int)</a></code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Please use <code>addChild(Node* child, int localZOrder, const std::string &amp;name)</code> instead. </p>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#a81750b6b1e67c0e99c71bae5ce5779bc">Node</a>.</p>

</div>
</div>
<a id="abd4f157c6f3d4e9f3da98d05b53e061b" name="abd4f157c6f3d4e9f3da98d05b53e061b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4f157c6f3d4e9f3da98d05b53e061b">&#9670;&#160;</a></span>addChild() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/da2/classax_1_1_node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>localZOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a child to the container with z order and tag. </p>
<p>If the child is added to a 'running' node, then 'onEnter' and 'onEnterTransitionDidFinish' will be called immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">localZOrder</td><td>Z order for drawing priority. Please refer to <code><a class="el" href="../../df/da2/classax_1_1_node.html#a30da2e2f84bf5dab27e7bf850ad80ec1" title="LocalZOrder is the &#39;key&#39; used to sort the node relative to its siblings.">setLocalZOrder(int)</a></code>. </td></tr>
    <tr><td class="paramname">name</td><td>A string to identify the node easily. Please refer to <code>setName(int)</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="../../df/da2/classax_1_1_node.html#abd4f157c6f3d4e9f3da98d05b53e061b">Node</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Sprite.h</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d3/d6b/namespaceax.html">ax</a></li><li class="navelem"><a class="el" href="../../da/d34/classax_1_1_sprite.html">Sprite</a></li>
    <li class="footer">Generated on Tue Oct 22 2024 14:17:43 for Axmol Engine by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7 </li>
  </ul>
</div>
</body>
</html>